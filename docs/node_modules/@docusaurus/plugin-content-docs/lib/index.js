"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateOptions = void 0;
const lodash_groupby_1 = __importDefault(require("lodash.groupby"));
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const lodash_pickby_1 = __importDefault(require("lodash.pickby"));
const lodash_sortby_1 = __importDefault(require("lodash.sortby"));
const globby_1 = __importDefault(require("globby"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const remark_admonitions_1 = __importDefault(require("remark-admonitions"));
const constants_1 = require("@docusaurus/core/lib/constants");
const utils_1 = require("@docusaurus/utils");
const order_1 = __importDefault(require("./order"));
const sidebars_1 = __importDefault(require("./sidebars"));
const metadata_1 = __importDefault(require("./metadata"));
const env_1 = __importDefault(require("./env"));
const version_1 = require("./version");
const constants_2 = require("./constants");
const pluginOptionSchema_1 = require("./pluginOptionSchema");
function pluginContentDocs(context, options) {
    if (options.admonitions) {
        options.remarkPlugins = options.remarkPlugins.concat([
            [remark_admonitions_1.default, options.admonitions],
        ]);
    }
    const { siteDir, generatedFilesDir, baseUrl } = context;
    const docsDir = path_1.default.resolve(siteDir, options.path);
    const sourceToPermalink = {};
    const dataDir = path_1.default.join(generatedFilesDir, 'docusaurus-plugin-content-docs');
    // Versioning.
    const env = env_1.default(siteDir, { disableVersioning: options.disableVersioning });
    const { versioning } = env;
    const { versions, docsDir: versionedDir, sidebarsDir: versionedSidebarsDir, } = versioning;
    const versionsNames = versions.map((version) => `version-${version}`);
    return {
        name: 'docusaurus-plugin-content-docs',
        getThemePath() {
            return path_1.default.resolve(__dirname, './theme');
        },
        extendCli(cli) {
            cli
                .command('docs:version')
                .arguments('<version>')
                .description('Tag a new version for docs')
                .action((version) => {
                version_1.docsVersion(version, siteDir, {
                    path: options.path,
                    sidebarPath: options.sidebarPath,
                });
            });
        },
        getPathsToWatch() {
            const { include } = options;
            let globPattern = include.map((pattern) => `${docsDir}/${pattern}`);
            if (versioning.enabled) {
                const docsGlob = include
                    .map((pattern) => versionsNames.map((versionName) => `${versionedDir}/${versionName}/${pattern}`))
                    .reduce((a, b) => a.concat(b), []);
                const sidebarsGlob = versionsNames.map((versionName) => `${versionedSidebarsDir}/${versionName}-sidebars.json`);
                globPattern = [...globPattern, ...sidebarsGlob, ...docsGlob];
            }
            return [...globPattern, options.sidebarPath];
        },
        getClientModules() {
            const modules = [];
            if (options.admonitions) {
                modules.push(require.resolve('remark-admonitions/styles/infima.css'));
            }
            return modules;
        },
        // Fetches blog contents and returns metadata for the contents.
        async loadContent() {
            const { include, sidebarPath } = options;
            if (!fs_extra_1.default.existsSync(docsDir)) {
                console.error(chalk_1.default.red(`No docs directory found for the docs plugin at: ${docsDir}`));
                return null;
            }
            // Prepare metadata container.
            const docsMetadataRaw = {};
            const docsPromises = [];
            const includeDefaultDocs = !(options.excludeNextVersionDocs && process.argv[2] === 'build');
            // Metadata for default/master docs files.
            if (includeDefaultDocs) {
                const docsFiles = await globby_1.default(include, {
                    cwd: docsDir,
                });
                docsPromises.push(Promise.all(docsFiles.map(async (source) => {
                    const metadata = await metadata_1.default({
                        source,
                        refDir: docsDir,
                        context,
                        options,
                        env,
                    });
                    docsMetadataRaw[metadata.id] = metadata;
                })));
            }
            // Metadata for versioned docs.
            if (versioning.enabled) {
                const versionedGlob = include
                    .map((pattern) => versionsNames.map((versionName) => `${versionName}/${pattern}`))
                    .reduce((a, b) => a.concat(b), []);
                const versionedFiles = await globby_1.default(versionedGlob, {
                    cwd: versionedDir,
                });
                docsPromises.push(Promise.all(versionedFiles.map(async (source) => {
                    const metadata = await metadata_1.default({
                        source,
                        refDir: versionedDir,
                        context,
                        options,
                        env,
                    });
                    docsMetadataRaw[metadata.id] = metadata;
                })));
            }
            // Load the sidebars and create docs ordering.
            const sidebarPaths = versionsNames.map((versionName) => `${versionedSidebarsDir}/${versionName}-sidebars.json`);
            if (includeDefaultDocs) {
                sidebarPaths.unshift(sidebarPath);
            }
            const loadedSidebars = sidebars_1.default(sidebarPaths);
            const order = order_1.default(loadedSidebars);
            await Promise.all(docsPromises);
            // Construct inter-metadata relationship in docsMetadata.
            const docsMetadata = {};
            const permalinkToSidebar = {};
            const versionToSidebars = {};
            Object.keys(docsMetadataRaw).forEach((currentID) => {
                var _a, _b, _c, _d, _e, _f;
                const { next: nextID, previous: previousID, sidebar } = order[currentID] || {};
                const previous = previousID
                    ? {
                        title: (_b = (_a = docsMetadataRaw[previousID]) === null || _a === void 0 ? void 0 : _a.title) !== null && _b !== void 0 ? _b : 'Previous',
                        permalink: (_c = docsMetadataRaw[previousID]) === null || _c === void 0 ? void 0 : _c.permalink,
                    }
                    : undefined;
                const next = nextID
                    ? {
                        title: (_e = (_d = docsMetadataRaw[nextID]) === null || _d === void 0 ? void 0 : _d.title) !== null && _e !== void 0 ? _e : 'Next',
                        permalink: (_f = docsMetadataRaw[nextID]) === null || _f === void 0 ? void 0 : _f.permalink,
                    }
                    : undefined;
                docsMetadata[currentID] = Object.assign(Object.assign({}, docsMetadataRaw[currentID]), { sidebar,
                    previous,
                    next });
                // sourceToPermalink and permalinkToSidebar mapping.
                const { source, permalink, version } = docsMetadataRaw[currentID];
                sourceToPermalink[source] = permalink;
                if (sidebar) {
                    permalinkToSidebar[permalink] = sidebar;
                    if (versioning.enabled && version) {
                        if (!versionToSidebars[version]) {
                            versionToSidebars[version] = new Set();
                        }
                        versionToSidebars[version].add(sidebar);
                    }
                }
            });
            const convertDocLink = (item) => {
                const docId = item.id;
                const docMetadata = docsMetadataRaw[docId];
                if (!docMetadata) {
                    throw new Error(`Bad sidebars file. The document id '${docId}' was used in the sidebar, but no document with this id could be found.
Available document ids=
- ${Object.keys(docsMetadataRaw).sort().join('\n- ')}`);
                }
                const { title, permalink, sidebar_label } = docMetadata;
                return {
                    type: 'link',
                    label: sidebar_label || title,
                    href: permalink,
                };
            };
            const normalizeItem = (item) => {
                switch (item.type) {
                    case 'category':
                        return Object.assign(Object.assign({}, item), { items: item.items.map(normalizeItem) });
                    case 'ref':
                    case 'doc':
                        return convertDocLink(item);
                    case 'link':
                    default:
                        return item;
                }
            };
            // Transform the sidebar so that all sidebar item will be in the
            // form of 'link' or 'category' only.
            // This is what will be passed as props to the UI component.
            const docsSidebars = Object.entries(loadedSidebars).reduce((acc, [sidebarId, sidebarItems]) => {
                acc[sidebarId] = sidebarItems.map(normalizeItem);
                return acc;
            }, {});
            return {
                docsMetadata,
                docsDir,
                docsSidebars,
                permalinkToSidebar: utils_1.objectWithKeySorted(permalinkToSidebar),
                versionToSidebars,
            };
        },
        async contentLoaded({ content, actions }) {
            if (!content || Object.keys(content.docsMetadata).length === 0) {
                return;
            }
            const { docLayoutComponent, docItemComponent, routeBasePath } = options;
            const { addRoute, createData, setGlobalData } = actions;
            const pluginInstanceGlobalData = {
                path: utils_1.normalizeUrl([baseUrl, options.routeBasePath]),
                latestVersionName: versioning.latestVersion,
                // Initialized empty, will be mutated
                versions: [],
            };
            setGlobalData(pluginInstanceGlobalData);
            const aliasedSource = (source) => `~docs/${path_1.default.relative(dataDir, source)}`;
            const createDocsBaseMetadata = (version) => {
                const { docsSidebars, permalinkToSidebar, versionToSidebars } = content;
                const neededSidebars = versionToSidebars[version] || new Set();
                return {
                    docsSidebars: version
                        ? lodash_pick_1.default(docsSidebars, Array.from(neededSidebars))
                        : docsSidebars,
                    permalinkToSidebar: version
                        ? lodash_pickby_1.default(permalinkToSidebar, (sidebar) => neededSidebars.has(sidebar))
                        : permalinkToSidebar,
                    version,
                };
            };
            const genRoutes = async (metadataItems) => {
                const routes = await Promise.all(metadataItems.map(async (metadataItem) => {
                    await createData(
                    // Note that this created data path must be in sync with
                    // metadataPath provided to mdx-loader.
                    `${utils_1.docuHash(metadataItem.source)}.json`, JSON.stringify(metadataItem, null, 2));
                    return {
                        path: metadataItem.permalink,
                        component: docItemComponent,
                        exact: true,
                        modules: {
                            content: metadataItem.source,
                        },
                    };
                }));
                return routes.sort((a, b) => a.path.localeCompare(b.path));
            };
            // We want latest version route to have lower priority
            // Otherwise `/docs/next/foo` would match
            // `/docs/:route` instead of `/docs/next/:route`.
            const getVersionRoutePriority = (version) => version === versioning.latestVersion ? -1 : undefined;
            // This is the base route of the document root (for a doc given version)
            // (/docs, /docs/next, /docs/1.0 etc...)
            // The component applies the layout and renders the appropriate doc
            const addVersionRoute = async (docsBasePath, docsBaseMetadata, docs, priority) => {
                var _a;
                const docsBaseMetadataPath = await createData(`${utils_1.docuHash(utils_1.normalizeUrl([docsBasePath, ':route']))}.json`, JSON.stringify(docsBaseMetadata, null, 2));
                const docsRoutes = await genRoutes(docs);
                const mainDoc = (_a = docs.find((doc) => doc.unversionedId === options.homePageId)) !== null && _a !== void 0 ? _a : docs[0];
                const toGlobalDataDoc = (doc) => ({
                    id: doc.unversionedId,
                    path: doc.permalink,
                });
                pluginInstanceGlobalData.versions.push({
                    name: docsBaseMetadata.version,
                    path: docsBasePath,
                    mainDocId: mainDoc.unversionedId,
                    docs: docs
                        .map(toGlobalDataDoc)
                        // stable ordering, useful for tests
                        .sort((a, b) => a.id.localeCompare(b.id)),
                });
                addRoute({
                    path: docsBasePath,
                    exact: false,
                    component: docLayoutComponent,
                    routes: docsRoutes,
                    modules: {
                        docsMetadata: aliasedSource(docsBaseMetadataPath),
                    },
                    priority,
                });
            };
            // If versioning is enabled, we cleverly chunk the generated routes
            // to be by version and pick only needed base metadata.
            if (versioning.enabled) {
                const docsMetadataByVersion = lodash_groupby_1.default(
                // sort to ensure consistent output for tests
                Object.values(content.docsMetadata).sort((a, b) => a.id.localeCompare(b.id)), 'version');
                await Promise.all(Object.keys(docsMetadataByVersion).map(async (version) => {
                    const docsMetadata = docsMetadataByVersion[version];
                    const isLatestVersion = version === versioning.latestVersion;
                    const docsBaseRoute = utils_1.normalizeUrl([
                        baseUrl,
                        routeBasePath,
                        isLatestVersion ? '' : version,
                    ]);
                    const docsBaseMetadata = createDocsBaseMetadata(version);
                    await addVersionRoute(docsBaseRoute, docsBaseMetadata, docsMetadata, getVersionRoutePriority(version));
                }));
            }
            else {
                const docsMetadata = Object.values(content.docsMetadata);
                const docsBaseMetadata = createDocsBaseMetadata(null);
                const docsBaseRoute = utils_1.normalizeUrl([baseUrl, routeBasePath]);
                await addVersionRoute(docsBaseRoute, docsBaseMetadata, docsMetadata);
            }
            // ensure version ordering on the global data (latest first)
            pluginInstanceGlobalData.versions = lodash_sortby_1.default(pluginInstanceGlobalData.versions, (versionMetadata) => {
                const orderedVersionNames = ['next', ...versions];
                return orderedVersionNames.indexOf(versionMetadata.name);
            });
        },
        configureWebpack(_config, isServer, utils) {
            const { getBabelLoader, getCacheLoader } = utils;
            const { rehypePlugins, remarkPlugins } = options;
            // Suppress warnings about non-existing of versions file.
            const stats = {
                warningsFilter: [constants_2.VERSIONS_JSON_FILE],
            };
            return {
                stats,
                devServer: {
                    stats,
                },
                resolve: {
                    alias: {
                        '~docs': dataDir,
                    },
                },
                module: {
                    rules: [
                        {
                            test: /(\.mdx?)$/,
                            include: [docsDir, versionedDir].filter(Boolean),
                            use: [
                                getCacheLoader(isServer),
                                getBabelLoader(isServer),
                                {
                                    loader: require.resolve('@docusaurus/mdx-loader'),
                                    options: {
                                        remarkPlugins,
                                        rehypePlugins,
                                        staticDir: path_1.default.join(siteDir, constants_1.STATIC_DIR_NAME),
                                        metadataPath: (mdxPath) => {
                                            // Note that metadataPath must be the same/in-sync as
                                            // the path from createData for each MDX.
                                            const aliasedSource = utils_1.aliasedSitePath(mdxPath, siteDir);
                                            return path_1.default.join(dataDir, `${utils_1.docuHash(aliasedSource)}.json`);
                                        },
                                    },
                                },
                                {
                                    loader: path_1.default.resolve(__dirname, './markdown/index.js'),
                                    options: {
                                        siteDir,
                                        docsDir,
                                        sourceToPermalink,
                                        versionedDir,
                                    },
                                },
                            ].filter(Boolean),
                        },
                    ],
                },
            };
        },
    };
}
exports.default = pluginContentDocs;
function validateOptions({ validate, options, }) {
    const validatedOptions = validate(pluginOptionSchema_1.PluginOptionSchema, options);
    return validatedOptions;
}
exports.validateOptions = validateOptions;
