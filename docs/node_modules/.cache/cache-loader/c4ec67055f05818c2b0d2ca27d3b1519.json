{"remainingRequest":"/Users/leonelsentana/Robyn/docs/node_modules/babel-loader/lib/index.js??ref--11-1!/Users/leonelsentana/Robyn/docs/node_modules/@docusaurus/mdx-loader/src/index.js??ref--11-2!/Users/leonelsentana/Robyn/docs/node_modules/@docusaurus/plugin-content-docs/lib/markdown/index.js??ref--11-3!/Users/leonelsentana/Robyn/docs/docs/doc12.md","dependencies":[{"path":"/Users/leonelsentana/Robyn/docs/docs/doc12.md","mtime":1605799856950},{"path":"/Users/leonelsentana/Robyn/docs/.docusaurus/docusaurus-plugin-content-docs/site-docs-doc-12-md-009.json","mtime":1605630467471},{"path":"/Users/leonelsentana/Robyn/docs/node_modules/cache-loader/dist/cjs.js","mtime":1604583336000},{"path":"/Users/leonelsentana/Robyn/docs/node_modules/babel-loader/lib/index.js","mtime":1604583336000},{"path":"/Users/leonelsentana/Robyn/docs/node_modules/@docusaurus/mdx-loader/src/index.js","mtime":1604583336000},{"path":"/Users/leonelsentana/Robyn/docs/node_modules/@docusaurus/plugin-content-docs/lib/markdown/index.js","mtime":1604583336000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9leHRlbmRzIGZyb20iL1VzZXJzL2xlb25lbHNlbnRhbmEvUm9ieW4vZG9jcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyI7aW1wb3J0IFJlYWN0IGZyb20ncmVhY3QnO2ltcG9ydHttZHh9ZnJvbSdAbWR4LWpzL3JlYWN0JztleHBvcnQgY29uc3QgZnJvbnRNYXR0ZXI9e2lkOidkb2MxMicsdGl0bGU6J1N0ZXAtYnktc3RlcCBndWlkZSd9O2V4cG9ydCBjb25zdCBtZXRhZGF0YT17InVudmVyc2lvbmVkSWQiOiJkb2MxMiIsImlkIjoiZG9jMTIiLCJpc0RvY3NIb21lUGFnZSI6ZmFsc2UsInRpdGxlIjoiU3RlcC1ieS1zdGVwIGd1aWRlIiwiZGVzY3JpcHRpb24iOiJMb2FkIGRhdGEgJiBzY3JpcHRzIiwic291cmNlIjoiQHNpdGUvZG9jcy9kb2MxMi5tZCIsInBlcm1hbGluayI6Ii9Sb2J5bi9kb2NzL2RvYzEyIiwiZWRpdFVybCI6Imh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2V4cGVyaW1lbnRhbC9Sb2J5bi9kb2NzL2RvYzEyLm1kIiwic2lkZWJhciI6InNvbWVTaWRlYmFyIiwicHJldmlvdXMiOnsidGl0bGUiOiJRdWljayBTdGFydCIsInBlcm1hbGluayI6Ii9Sb2J5bi9kb2NzL2RvYzMifSwibmV4dCI6eyJ0aXRsZSI6IlJpZGdlIFJlZ3Jlc3Npb24iLCJwZXJtYWxpbmsiOiIvUm9ieW4vZG9jcy9kb2M0In19Oy8qIEBqc3ggbWR4ICovZXhwb3J0IGNvbnN0IHJpZ2h0VG9jPVt7dmFsdWU6J0xvYWQgZGF0YSAmYW1wOyBzY3JpcHRzJyxpZDonbG9hZC1kYXRhLS1zY3JpcHRzJyxjaGlsZHJlbjpbXX0se3ZhbHVlOidTZXQgbW9kZWwgaW5wdXQgdmFyaWFibGVzJyxpZDonc2V0LW1vZGVsLWlucHV0LXZhcmlhYmxlcycsY2hpbGRyZW46W3t2YWx1ZTonc2V0X2NvdW50cnknLGlkOidzZXRfY291bnRyeScsY2hpbGRyZW46W119LHt2YWx1ZTonc2V0X2RhdGVWYXJOYW1lJyxpZDonc2V0X2RhdGV2YXJuYW1lJyxjaGlsZHJlbjpbXX0se3ZhbHVlOidzZXRfZGVwVmFyTmFtZSBhbmQgc2V0X2RlcFZhclR5cGUnLGlkOidzZXRfZGVwdmFybmFtZS1hbmQtc2V0X2RlcHZhcnR5cGUnLGNoaWxkcmVuOltdfSx7dmFsdWU6J1NldCBQcm9waGV0IHZhcmlhYmxlcycsaWQ6J3NldC1wcm9waGV0LXZhcmlhYmxlcycsY2hpbGRyZW46W119LHt2YWx1ZTonU2V0IEJhc2VsaW5lIHZhcmlhYmxlcycsaWQ6J3NldC1iYXNlbGluZS12YXJpYWJsZXMnLGNoaWxkcmVuOltdfSx7dmFsdWU6J3NldF9tZWRpYVZhck5hbWUgYW5kIHNldF9tZWRpYVNwZW5kTmFtZScsaWQ6J3NldF9tZWRpYXZhcm5hbWUtYW5kLXNldF9tZWRpYXNwZW5kbmFtZScsY2hpbGRyZW46W119LHt2YWx1ZTonU2V0IGZhY3RvciB2YXJpYWJsZXMnLGlkOidzZXQtZmFjdG9yLXZhcmlhYmxlcycsY2hpbGRyZW46W119XX0se3ZhbHVlOidTZXQgZ2xvYmFsIG1vZGVsIHBhcmFtZXRlcnMnLGlkOidzZXQtZ2xvYmFsLW1vZGVsLXBhcmFtZXRlcnMnLGNoaWxkcmVuOltdfSx7dmFsdWU6J1R1bmUgY2hhbm5lbCBoeXBlcnBhcmFtZXRlcnMgYm91bmRzJyxpZDondHVuZS1jaGFubmVsLWh5cGVycGFyYW1ldGVycy1ib3VuZHMnLGNoaWxkcmVuOltdfSx7dmFsdWU6J1Bsb3R0aW5nIGFuZCB1bmRlcnN0YW5kaW5nIHJlc3VsdHMnLGlkOidwbG90dGluZy1hbmQtdW5kZXJzdGFuZGluZy1yZXN1bHRzJyxjaGlsZHJlbjpbe3ZhbHVlOidmLnBsb3RTcGVuZE1vZGVsOiBQbG90dGluZyB0aGUgc3BlbmQtcmVhY2ggZml0dGluZyB3aXRoIE1pY2hhZWxpcy1NZW50ZW4gbW9kZWwnLGlkOidmcGxvdHNwZW5kbW9kZWwtcGxvdHRpbmctdGhlLXNwZW5kLXJlYWNoLWZpdHRpbmctd2l0aC1taWNoYWVsaXMtbWVudGVuLW1vZGVsJyxjaGlsZHJlbjpbXX0se3ZhbHVlOidmLnBsb3RIeXBlclNhbXA6IGNoZWNraW5nIGxhdGluIGh5cGVyY3ViZSBzYW1wbGluZyBkaXN0cmlidXRpb24nLGlkOidmcGxvdGh5cGVyc2FtcC1jaGVja2luZy1sYXRpbi1oeXBlcmN1YmUtc2FtcGxpbmctZGlzdHJpYnV0aW9uJyxjaGlsZHJlbjpbXX0se3ZhbHVlOidmLnBsb3RUcmVuZFNlYXNvbjogVW5kZXJzdGFuZGluZyB0cmVuZCBhbmQgc2Vhc29uYWxpdHknLGlkOidmcGxvdHRyZW5kc2Vhc29uLXVuZGVyc3RhbmRpbmctdHJlbmQtYW5kLXNlYXNvbmFsaXR5JyxjaGlsZHJlbjpbXX0se3ZhbHVlOidiZXN0QWRzdG9jazogQWRzdG9jayBjYXJyeW92ZXIgYW5kIGRpbWluaXNoaW5nIHJldHVybnMgZWZmZWN0cycsaWQ6J2Jlc3RhZHN0b2NrLWFkc3RvY2stY2FycnlvdmVyLWFuZC1kaW1pbmlzaGluZy1yZXR1cm5zLWVmZmVjdHMnLGNoaWxkcmVuOltdfSx7dmFsdWU6J2YucGxvdEJlc3REZWNvbXA6IFVuZGVyc3RhbmRpbmcgdGhlIGVmZmVjdCBvZiBiYXNlbGluZSwgbWVkaWEgdmFyaWFibGVzIHRyZW5kIGFuZCBzZWFzb25hbGl0eSBhbG9uZyB0aW1lJyxpZDonZnBsb3RiZXN0ZGVjb21wLXVuZGVyc3RhbmRpbmctdGhlLWVmZmVjdC1vZi1iYXNlbGluZS1tZWRpYS12YXJpYWJsZXMtdHJlbmQtYW5kLXNlYXNvbmFsaXR5LWFsb25nLXRpbWUnLGNoaWxkcmVuOltdfSx7dmFsdWU6J2YucGxvdE1BUEVDb252ZXJnZTogVW5kZXJzdGFuZGluZyBNQVBFIGV2b2x1dGlvbiBwZXIgUmFuZG9tIFNlYXJjaCBpdGVyYXRpb24gYW5kIG1pbnV0ZXMgc3BlbnQnLGlkOidmcGxvdG1hcGVjb252ZXJnZS11bmRlcnN0YW5kaW5nLW1hcGUtZXZvbHV0aW9uLXBlci1yYW5kb20tc2VhcmNoLWl0ZXJhdGlvbi1hbmQtbWludXRlcy1zcGVudCcsY2hpbGRyZW46W119LHt2YWx1ZTonZi5wbG90QmVzdE1vZERpYWdub3N0aWM6IHBsb3QgYmVzdCBtb2RlbCBkaWFnbm9zdGljczogcmVzaWR1YWwgdnMgZml0dGVkLCBRUSBwbG90IGFuZCByZXNpZHVhbCB2cy4gYWN0dWFsJyxpZDonZnBsb3RiZXN0bW9kZGlhZ25vc3RpYy1wbG90LWJlc3QtbW9kZWwtZGlhZ25vc3RpY3MtcmVzaWR1YWwtdnMtZml0dGVkLXFxLXBsb3QtYW5kLXJlc2lkdWFsLXZzLWFjdHVhbCcsY2hpbGRyZW46W119XX1dO2NvbnN0IGxheW91dFByb3BzPXtyaWdodFRvY307Y29uc3QgTURYTGF5b3V0PSJ3cmFwcGVyIjtleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KHtjb21wb25lbnRzLC4uLnByb3BzfSl7cmV0dXJuIG1keChNRFhMYXlvdXQsX2V4dGVuZHMoe30sbGF5b3V0UHJvcHMscHJvcHMse2NvbXBvbmVudHM6Y29tcG9uZW50cyxtZHhUeXBlOiJNRFhMYXlvdXQifSksbWR4KCJoMiIseyJpZCI6ImxvYWQtZGF0YS0tc2NyaXB0cyJ9LGBMb2FkIGRhdGEgJiBzY3JpcHRzYCksbWR4KCJwIixudWxsLGBUaGUgZmlyc3Qgc3RlcCBpcyB0byBsb2FkIGRhdGEgYW5kIHNjcmlwdHMsIHlvdSBjYW4gc3RhcnQgd2l0aCBvdXIgc2ltdWxhdGVkIGRhdGEgZmlsZSAoZGVfc2ltdWxhdGVkX2RhdGEuY3N2KSBpZiB5b3Ugd2FudCB0byBwcmFjdGljZSBhdCB0aGUgYmVnaW5uaW5nLmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgc2NyaXB0X3BhdGggPC0gc3RyX3N1Yihyc3R1ZGlvYXBpOjpnZXRBY3RpdmVEb2N1bWVudENvbnRleHQoKSRwYXRoLCBzdGFydCA9IDEsIGVuZCA9IG1heCh1bmxpc3Qoc3RyX2xvY2F0ZV9hbGwocnN0dWRpb2FwaTo6Z2V0QWN0aXZlRG9jdW1lbnRDb250ZXh0KCkkcGF0aCwgIi8iKSkpKQpkdF9pbnB1dCA8LSBmcmVhZChwYXN0ZTAoc2NyaXB0X3BhdGgsJ2RlX3NpbXVsYXRlZF9kYXRhLmNzdicpKQpob2xpZGF5cyA8LSBmcmVhZChwYXN0ZTAoc2NyaXB0X3BhdGgsJ2dlbmVyYXRlZF9ob2xpZGF5cy5jc3YnKSkKYCkpLG1keCgicCIsbnVsbCxgT3VyIHNjcmlwdCBoYXMgYmVlbiBkZXNpZ25lZCB0byBwdWxsIGZpbGVzIGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgZm9sZGVyIHdoZXJlIHRoZSDigJhmYl9uZXh0Z2VuX21tbS5leGVjLlLigJkgc2NyaXB0IHJlc2lkZXMuIElmIHlvdSB3b3VsZCBsaWtlIHRvIHVzZSBhIG5ldyBkYXRhIGlucHV0IGZpbGUgaW5zdGVhZCBvZiBvdXIgc2ltdWxhdGVkIGRhdGEgeW91IHdpbGwgbmVlZCB0byBzYXZlIGl0IGluIHRoZSBzYW1lIGZvbGRlciBhbmQgcmVwbGFjZSBkdF9pbnB1dC5jc3YgZmlsZSBhcyBpbiB0aGUgZXhhbXBsZSBiZWxvdzoKQmVmb3JlCmR0X2lucHV0IDwtIGZyZWFkKHBhc3RlMChzY3JpcHRfcGF0aCwnZGVfc2ltdWxhdGVkX2RhdGEuY3N2JykpCkFmdGVyCmR0X2lucHV0IDwtIGZyZWFkKHBhc3RlMChzY3JpcHRfcGF0aCwneW91cl9pbnB1dF9kYXRhX2ZpbGUuY3N2JykpYCksbWR4KCJoMiIseyJpZCI6InNldC1tb2RlbC1pbnB1dC12YXJpYWJsZXMifSxgU2V0IG1vZGVsIGlucHV0IHZhcmlhYmxlc2ApLG1keCgicCIsbnVsbCxgT25jZSB5b3UgaGF2ZSBkZWZpbmVkIHRoZSBpbnB1dCBmaWxlcyB0byB3b3JrIHdpdGggYW5kIGxvYWRlZCB0byB0aGUgc291cmNlIGFsbCB0aGUgZnVuY3Rpb25zIG5lZWRlZCB0byBydW4gdGhlIGNvZGUuIFlvdSB3aWxsIG5lZWQgdG8gZGVmaW5lIGFuZCBzZXQgdGhlIGlucHV0IHZhcmlhYmxlcy5gKSxtZHgoImgzIix7ImlkIjoic2V0X2NvdW50cnkifSxgc2V0X2NvdW50cnlgKSxtZHgoInAiLG51bGwsYFRoZSBmaXJzdCB2YXJpYWJsZSB0byBkZWNsYXJlIGlzIHRoZSBjb3VudHJ5LiBXZSByZWNvbW1lbmQgdXNpbmcgb25seSBvbmUgY291bnRyeSBlc3BlY2lhbGx5IGlmIHlvdSBhcmUgcGxhbm5pbmcgdG8gbGV2ZXJhZ2UgcHJvcGhldCBmb3IgdHJlbmQgYW5kIHNlYXNvbmFsaXR5IHdoaWNoIGF1dG9tYXRpY2FsbHkgcHVsbHMgaG9saWRheXMgZm9yIHRoZSBjb3VudHJ5IHlvdSBoYXZlIHNlbGVjdGVkIGFuZCBzaW1wbGlmaWVzIHRoZSBwcm9jZXNzLmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgc2V0X2NvdW50cnkgPC0gIkRFIiAjIG9ubHkgb25lIGNvdW50cnkgYWxsb3dlZC4gVXNlZCBpbiBwcm9waGV0IGhvbGlkYXlzCmApKSxtZHgoImgzIix7ImlkIjoic2V0X2RhdGV2YXJuYW1lIn0sYHNldF9kYXRlVmFyTmFtZWApLG1keCgicCIsbnVsbCxgRm9yIGRhdGUgdmFyaWFibGVzIHlvdSBtdXN0IGhhdmUgaW4gbWluZCB0aGF0IHRoZSBEQVRFIGNvbHVtbiBpbiB5b3VyIGRhdGFzZXQgaGFzIHRvIGJlIGluICAieXl5eS1tbS1kZCAiIGZvcm1hdC4gaWUuICIyMDIwLTAxLTAxImApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgc2V0X2RhdGVWYXJOYW1lIDwtIGMoIkRBVEUiKSAjIGRhdGUgbXVzdCBiZSBmb3JtYXQgIjIwMjAtMDEtMDEiCmApKSxtZHgoImgzIix7ImlkIjoic2V0X2RlcHZhcm5hbWUtYW5kLXNldF9kZXB2YXJ0eXBlIn0sYHNldF9kZXBWYXJOYW1lIGFuZCBzZXRfZGVwVmFyVHlwZWApLG1keCgicCIsbnVsbCxgU2V0dGluZyB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIGlzIGJhc2ljYWxseSB0aGUgb3V0Y29tZSB5b3UgYXJlIHRyeWluZyB0byBtZWFzdXJlLiBXZSBvbmx5IGFjY2VwdCBvbmUgZGVwZW5kZW50IHZhcmlhYmxlIHVuZGVyIHNldF9kZXBWYXJOYW1lLiBUaGlzIHZhcmlhYmxlIGNhbiB0YWtlIHRoZSBmb3JtIG9mIHJldmVudWUgKFNhbGVzIG9yIHByb2ZpdCBpbiBtb25ldGFyeSB2YWx1ZXMpIG9yIGNvbnZlcnNpb24gKE51bWJlciBvZiB0cmFuc2FjdGlvbnMsIHVuaXRzIHNvbGQpIHdoaWNoIHlvdSB3aWxsIGluZGljYXRlIHdoZW4gZGVmaW5pbmcgdGhlIHNldF9kZXBWYXJUeXBlIHZhcmlhYmxlLmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgc2V0X2RlcFZhck5hbWUgPC0gYygicmV2ZW51ZSIpICMgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGRlcGVuZGVudCB2YXJpYWJsZQpzZXRfZGVwVmFyVHlwZSA8LSAicmV2ZW51ZSIgIyAicmV2ZW51ZSIgb3IgImNvbnZlcnNpb24iIGFyZSBhbGxvd2VkCmApKSxtZHgoImgzIix7ImlkIjoic2V0LXByb3BoZXQtdmFyaWFibGVzIn0sYFNldCBQcm9waGV0IHZhcmlhYmxlc2ApLG1keCgiaDQiLHsiaWQiOiJhY3RpdmF0ZV9wcm9waGV0In0sYGFjdGl2YXRlX3Byb3BoZXRgKSxtZHgoInAiLG51bGwsYEZpcnN0IHlvdSB3aWxsIG5lZWQgdG8gaW5kaWNhdGUgdGhlIG1vZGVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIHR1cm4gb24gb3Igb2ZmIHRoZSBQcm9waGV0IGZlYXR1cmUgaW4gdGhlIGNvZGUgdG8gYmUgdXNlZCBmb3Igc2Vhc29uYWxpdHksIHRyZW5kIGFuZCBob2xpZGF5cy4gVCAoVHJ1ZSkgbWVhbnMgaXQgaXMgYWN0aXZhdGVkIGFuZCBGIChGYWxzZSkgZGVhY3RpdmF0ZWQuYCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGBhY3RpdmF0ZV9wcm9waGV0IDwtIFQKYCkpLG1keCgiaDQiLHsiaWQiOiJzZXRfcHJvcGhldCJ9LGBzZXRfcHJvcGhldGApLG1keCgicCIsbnVsbCxgVGhlIG5leHQgc3RlcCBpcyB0byBzZWxlY3Qgd2hpY2ggb2YgdGhlIHByb3ZpZGVkIG91dGNvbWVzIG9mIFByb3BoZXQgeW91IHdpbGwgdXNlIGluIHRoZSBtb2RlbC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gYXQgbGVhc3Qga2VlcCB0cmVuZCBhbmQgaG9saWRheXMuIFBsZWFzZSBoYXZlIGluIG1pbmQgdGhhdCAidHJlbmQiLCJzZWFzb24iLCAid2Vla2RheSIsICJob2xpZGF5IiBhcmUgcHJvdmlkZWQgYW5kIGNhc2Utc2Vuc2l0aXZlLmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgc2V0X3Byb3BoZXQgPC0gYygidHJlbmQiLCAic2Vhc29uIiwgImhvbGlkYXkiKQpgKSksbWR4KCJoNCIseyJpZCI6InNldF9wcm9waGV0dmFyc2lnbiJ9LGBzZXRfcHJvcGhldFZhclNpZ25gKSxtZHgoInAiLG51bGwsYFlvdSBtYXkgZGVmaW5lIHRoZSB2YXJpYWJsZSBzaWduIGNvbnRyb2wgZm9yIHByb3BoZXQgdmFyaWFibGVzIHRvIGJlICJkZWZhdWx0IiwgInBvc2l0aXZlIiwgb3IgIm5lZ2F0aXZlIi4gSWYgeW91IGFyZSBleHBlY3RpbmcgY29lZmZpY2llbnRzIGZvciBwcm9waGV0IHZhcmlhYmxlcyBzdWNoIGFzICJ0cmVuZCIsICJzZWFzb24iLCAiaG9saWRheSIgdG8gYmUgZGVmYXVsdCAoZWl0aGVyIHBvc2l0aXZlIG9yIG5lZ2F0aXZlKSwgcG9zaXRpdmUgb3IgbmVnYXRpdmUuIFdlIHJlY29tbWVuZCB1c2luZyBkZWZhdWx0LiBQbGVhc2UgcmVtZW1iZXIgdGhlIG9iamVjdCBkZWNsYXJlZCBtdXN0IGJlIHNhbWUgbGVuZ3RoIGFzIHNldF9wcm9waGV04oCZc2ApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgc2V0X3Byb3BoZXRWYXJTaWduIDwtIGMoImRlZmF1bHQiLCJkZWZhdWx0IiwgImRlZmF1bHQiKQpgKSksbWR4KCJoNCIseyJpZCI6InRlc3QtYW5kLXZpc3VhbGlzZS1wcm9waGV0cy1kZWNvbXBvc2l0aW9uIn0sYFRlc3QgYW5kIHZpc3VhbGlzZSBwcm9waGV04oCZcyBkZWNvbXBvc2l0aW9uYCksbWR4KCJwIixudWxsLGBZb3UgbWF5IGRyaWxsLWRvd24gaW50byBwcm9waGV0IHJlc3VsdHMgdG8gdW5kZXJzdGFuZCBiZXR0ZXIgdGhlIG91dGNvbWVzIHByb3ZpZGVkIGJ5IHRoZSB0b29sIGJ5IGV4ZWN1dGluZyB0aGUgZm9sbG93aW5nIGNvbW1hbmQuYCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGBmLmdldFByb3BoZXQoZHRfaW5wdXQpCmApKSxtZHgoImgzIix7ImlkIjoic2V0LWJhc2VsaW5lLXZhcmlhYmxlcyJ9LGBTZXQgQmFzZWxpbmUgdmFyaWFibGVzYCksbWR4KCJwIixudWxsLGBUaGUgZm9sbG93aW5nIHN0ZXAgaXMgdG8gc2V0IHRoZSBiYXNlbGluZSB2YXJpYWJsZXMgd2hpY2ggdHlwaWNhbGx5IGFyZSB0aGluZ3MgbGlrZSBjb21wZXRpdG9ycywgcHJpY2luZywgcHJvbW90aW9ucywgdGVtcGVyYXR1cmUsIHVuZW1wbG95bWVudCByYXRlIGFuZCBhbnkgb3RoZXIgdmFyaWFibGUgdGhhdCBpcyBub3QgbWVkaWEgZXhwb3N1cmUgYnV0IGhhcyBhIHN0cm9uZyByZWxhdGlvbnNoaXAgd2l0aCBzYWxlcyBvdXRjb21lcy4gWW91IHdpbGwgbmVlZCB0byBpbmRpY2F0ZSB0aGUgbW9kZWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gdHVybiBvbiBvciBvZmYgYmFzZWxpbmUgdmFyaWFibGVzIGluIHRoZSBjb2RlLiBUIChUcnVlKSBtZWFucyBpdCBpcyBhY3RpdmF0ZWQgYW5kIEYgKEZhbHNlKSBkZWFjdGl2YXRlZC5gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYGFjdGl2YXRlX2Jhc2VsaW5lIDwtIFQKYCkpLG1keCgicCIsbnVsbCxgWW91IG1heSB0aGVuIGRlZmluZSB0aGUgZGlmZmVyZW50IGJhc2VsaW5lIHZhcmlhYmxlcyB5b3Ugd291bGQgbGlrZSB0byBjb25zaWRlci5gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYHNldF9iYXNlVmFyTmFtZSA8LSBjKCJwcm9tb3Rpb25zIiwgInByaWNlIGNoYW5nZXMiLCAiY29tcGV0aXRvcnMgc2FsZXMiKQpgKSksbWR4KCJwIixudWxsLGBZb3UgbWF5IGFwcGx5IHNpZ24gY29udHJvbCBmb3IgYmFzZWxpbmUgdmFyaWFibGVzIHRvIGJlICJkZWZhdWx0IiwgInBvc2l0aXZlIiwgb3IgIm5lZ2F0aXZlIi4gSWYgeW91IGFyZSBleHBlY3RpbmcgY29lZmZpY2llbnRzIGZvciBiYXNlbGluZSB2YXJpYWJsZXMgc3VjaCBhcyAicHJvbW90aW9ucyIsICJwcmljZSBjaGFuZ2VzIiwgImNvbXBldGl0b3JzIHNhbGVzIiB0byBiZSBkZWZhdWx0IChlaXRoZXIgcG9zaXRpdmUgb3IgbmVnYXRpdmUpLCBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBkZXBlbmRpbmcgb24gaXRzIGV4cGVjdGVkIHJlbGF0aW9uc2hpcCB3aXRoIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUuIEZvciBleGFtcGxlLCByYWlueSB3ZWF0aGVyIG1heSBoYXZlIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW1wYWN0IGluIHNhbGVzIGRlcGVuZGluZyBvbiB0aGUgYnVzaW5lc3MuIFBsZWFzZSByZW1lbWJlciB0aGUgb2JqZWN0IGRlY2xhcmVkIG11c3QgYmUgc2FtZSBsZW5ndGggYXMgc2V0X2Jhc2VWYXJOYW1l4oCZc2ApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgc2V0X2Jhc2VWYXJTaWduIDwtIGMoIm5lZ2F0aXZlIikgIyBjKCJkZWZhdWx0IiwgInBvc2l0aXZlIiwgYW5kICJuZWdhdGl2ZSIpCmApKSxtZHgoImgzIix7ImlkIjoic2V0X21lZGlhdmFybmFtZS1hbmQtc2V0X21lZGlhc3BlbmRuYW1lIn0sYHNldF9tZWRpYVZhck5hbWUgYW5kIHNldF9tZWRpYVNwZW5kTmFtZWApLG1keCgicCIsbnVsbCxgVGhlcmUgaXMgb25lIGtleSByZXN0cmljdGlvbiB0byBoYXZlIGluIG1pbmQgaGVyZSwgeW91IG11c3QgaGF2ZSBzcGVuZCB2YXJpYWJsZXMgZGVjbGFyZWQgZm9yIGV2ZXJ5IG1lZGlhIGNoYW5uZWwgeW91IHdvdWxkIGxpa2UgdG8gbWVhc3VyZS4gU28gdGhleSBoYXZlIHRvIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFuZCBzYW1lIGxlbmd0aCBhcyBzZXRfbWVkaWFWYXJOYW1lIHZhcmlhYmxlcy5gKSxtZHgoInAiLG51bGwsYENvcnJlY3RgKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYHNldF9tZWRpYVZhck5hbWUgPC0gYygidHZfUyIgICAgLCJvb2hfUyIsICAgInByaW50X1MiICAgLCJmYWNlYm9va19JIiAgICwic2VhcmNoX2NsaWNrc19QIikKCnNldF9tZWRpYVNwZW5kTmFtZSA8LSBjKCJ0dl9TIiAgLCJvb2hfUyIsICAgInByaW50X1MiICAgLCJmYWNlYm9va19TIiAgICwic2VhcmNoX1MiKQpgKSksbWR4KCJwIixudWxsLGBJbmNvcnJlY3RgKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYHNldF9tZWRpYVZhck5hbWUgPC0gYygidHZfUyIgICAgLCJvb2hfUyIsICAgInByaW50X1MiICAgLCJmYWNlYm9va19JIiAgICwic2VhcmNoX2NsaWNrc19QIikKCnNldF9tZWRpYVNwZW5kTmFtZSA8LSBjKCJ0dl9TIiAgLCJvb2hfUyIsICAgInByaW50X1MiKQpgKSksbWR4KCJoNCIseyJpZCI6InNldF9tZWRpYXZhcnNpZ24ifSxgc2V0X21lZGlhVmFyU2lnbmApLG1keCgicCIsbnVsbCxgWW91IG1heSBhcHBseSBzaWduIGNvbnRyb2wgZm9yIG1lZGlhIHZhcmlhYmxlcyB0byBiZSAiZGVmYXVsdCIsICJwb3NpdGl2ZSIsIG9yICJuZWdhdGl2ZSIuIElmIHlvdSBhcmUgZXhwZWN0aW5nIGNvZWZmaWNpZW50cyBmb3IgYmFzZWxpbmUgdmFyaWFibGVzIHN1Y2ggYXMgInR2IiwgInByaW50IiwgImZhY2Vib29rIiB0byBiZSBkZWZhdWx0IChlaXRoZXIgcG9zaXRpdmUgb3IgbmVnYXRpdmUpLCBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBkZXBlbmRpbmcgb24gaXRzIGV4cGVjdGVkIHJlbGF0aW9uc2hpcCB3aXRoIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUuIFdlIHJlY29tbWVuZCB1c2luZyBwb3NpdGl2ZSBmb3IgYWxsLiBQbGVhc2UgcmVtZW1iZXIgdGhlIG9iamVjdCBkZWNsYXJlZCBtdXN0IGJlIHNhbWUgbGVuZ3RoIGFzIHNldF9tZWRpYVZhck5hbWXigJlzYCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGBzZXRfbWVkaWFWYXJTaWduIDwtIGMoInBvc2l0aXZlIiwgInBvc2l0aXZlIiwgInBvc2l0aXZlIiwgInBvc2l0aXZlIiwgInBvc2l0aXZlIikKYCkpLG1keCgiaDMiLHsiaWQiOiJzZXQtZmFjdG9yLXZhcmlhYmxlcyJ9LGBTZXQgZmFjdG9yIHZhcmlhYmxlc2ApLG1keCgicCIsbnVsbCxgSWYgYW55IHZhcmlhYmxlIGFib3ZlIHNob3VsZCBiZSBmYWN0b3IgcGxlYXNlIGluY2x1ZGUgaXQgaW4gdGhpcyBzZWN0aW9uIG9mIHRoZSBjb2RlLCBvdGhlcndpc2UgbGVhdmUgaXQgZW1wdHkgYXMgYnkgZGVmYXVsdCDigJxjKCnigJ1gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYHNldF9mYWN0b3JWYXJOYW1lIDwtIGMoKQpgKSksbWR4KCJoMiIseyJpZCI6InNldC1nbG9iYWwtbW9kZWwtcGFyYW1ldGVycyJ9LGBTZXQgZ2xvYmFsIG1vZGVsIHBhcmFtZXRlcnNgKSxtZHgoInAiLG51bGwsYEluIHRoaXMgc2VjdGlvbiB5b3Ugd2lsbCBoYXZlIHRvIGRlZmluZSBwYXJhbWV0ZXJzIHZhbHVlcyBhbmQgYm91bmRzIGZvciB0aGUgbW9kZWwgdG8gc3RhcnQgd29ya2luZzpgKSxtZHgoIm9sIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJvbCJ9LG1keCgicCIse3BhcmVudE5hbWU6ImxpIn0sYFRoZSBgLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LGBudW1iZXIgb2YgY29yZXNgKSxgIGluIHlvdXIgY29tcHV0ZXIgdG8gYmUgdXNlZCBmb3IgYCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSxgcGFyYWxsZWwgY29tcHV0aW5nYCkpKSxtZHgoImxpIix7cGFyZW50TmFtZToib2wifSxtZHgoInAiLHtwYXJlbnROYW1lOiJsaSJ9LGBUaGUgYCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSxgZGF0YSB0cmFpbmluZyBzaXplYCksYCAoc2V0X21vZFRyYWluU2l6ZSkgd2hpY2ggd2lsbCBpbmRpY2F0ZSB0aGUgcGVyY2VudGFnZSBvZiBkYXRhIHRvIGJlIHVzZWQgdG8gdHJhaW4gdGhlIG1vZGVsLCB0aGVyZWZvcmUsIHRoZSBwZXJjZW50YWdlIGxlZnQgKDEtIHRyYWluaW5nIHNpemUpIHRvIHZhbGlkYXRlIHRoZSBtb2RlbC5gKSxtZHgoIm9sIix7cGFyZW50TmFtZToibGkifSxtZHgoImxpIix7cGFyZW50TmFtZToib2wifSxgVGhlIGZ1bmN0aW9uIGYucGxvdFRyYWluU2l6ZSBoZWxwcyB5b3Ugc2VsZWN0IHRoZSBiZXN0IHNwbGl0LiBTZXQgdGhlIGZ1bmN0aW9uIHRvIGYucGxvdFRyYWluU2l6ZShUUlVFKSB0byBwbG90IHRoZSBCaGF0dGFjaGFyeXlhIGNvZWZmaWNpZW50LCBhbiBpbmRpY2F0b3IgZm9yIHRoZSBzaW1pbGFyaXR5IG9mIHR3byBkaXN0cmlidXRpb25zLCBmb3IgdGhlIHRyYWluaW5nIHNpemUgNTAtOTAlLiBUaGUgaGlnaGVyIHRoZSBCaGF0dGEgY29lZmZpY2llbnQsIHRoZSBtb3JlIHNpbWlsYXIgdGhlIHRyYWluIGFuZCB0ZXN0IGRhdGEgc3BsaXRzIGFuZCB0aHVzIHRoZSBiZXR0ZXIgdGhlIHBvdGVudGlhbCBtb2RlbCBmaXQgaW4gdGhlIGVuZC5gKSkpLG1keCgibGkiLHtwYXJlbnROYW1lOiJvbCJ9LG1keCgicCIse3BhcmVudE5hbWU6ImxpIn0sYFRoZSBhZHN0b2NraW5nIG1ldGhvZCB3aGljaCBjYW4gYmUgYCxtZHgoImEiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwIn0seyJocmVmIjoiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvbWV0cmljX2Rpc3RyaWJ1dGlvbiJ9KSxgR2VvbWV0cmljYCksYCBvciBgLG1keCgiYSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InAifSx7ImhyZWYiOiJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWlidWxsX2Rpc3RyaWJ1dGlvbiJ9KSxgV2VpYnVsbGApLGAgZGlzdHJpYnV0aW9ucy5gKSksbWR4KCJsaSIse3BhcmVudE5hbWU6Im9sIn0sbWR4KCJwIix7cGFyZW50TmFtZToibGkifSxgVGhlIGAsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sYG51bWJlciBvZiBpdGVyYXRpb25zYCksYCAoc2V0X2l0ZXIpIHlvdXIgbW9kZWwgd2lsbCBoYXZlIHRvIGZpbmQgb3B0aW11bSB2YWx1ZXMgZm9yIGNvZWZmaWNpZW50cy5gKSksbWR4KCJsaSIse3BhcmVudE5hbWU6Im9sIn0sbWR4KCJwIix7cGFyZW50TmFtZToibGkifSxgVGhlIGAsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sYGh5cGVycGFyYW1ldGVycyBib3VuZHNgKSxgIHdoaWNoIHdlIHJlY29tbWVuZCB0byBsZWF2ZSBhcyBkZWZhdWx0IGJ1dCBjYW4gYmUgY2hhbmdlZCBhY2NvcmRpbmcgdG8gbGVhcm5pbmdzIGZyb20gbW9kZWwgaXRlcmF0aW9ucyBhbmQgYW5hbHlzdHPigJkgcGFzdCBleHBlcmllbmNlLmApLG1keCgib2wiLHtwYXJlbnROYW1lOiJsaSJ9LG1keCgibGkiLHtwYXJlbnROYW1lOiJvbCJ9LG1keCgicCIse3BhcmVudE5hbWU6ImxpIn0sbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sYFRoZSBkZWZpbml0aW9uIG9mIGVhY2ggaHlwZXJwYXJhbWV0ZXI6YCkpLG1keCgib2wiLHtwYXJlbnROYW1lOiJsaSJ9LG1keCgibGkiLHtwYXJlbnROYW1lOiJvbCJ9LG1keCgic3Ryb25nIix7cGFyZW50TmFtZToibGkifSxgVGhldGFzYCksYDogR2VvbWV0cmljIGZ1bmN0aW9uIGRlY2F5IHJhdGVgKSxtZHgoImxpIix7cGFyZW50TmFtZToib2wifSxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6ImxpIn0sYFNoYXBlc2ApLGA6IFdlaWJ1bGwgcGFyYW1ldGVyIHRoYXQgY29udHJvbHMgdGhlIGRlY2F5IHNoYXBlIGJldHdlZW4gZXhwb25lbnRpYWwgYW5kIHMtc2hhcGVgKSxtZHgoImxpIix7cGFyZW50TmFtZToib2wifSxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6ImxpIn0sYFNjYWxlc2ApLGA6IFdlaWJ1bGwgcGFyYW1ldGVyIHRoYXQgY29udHJvbHMgdGhlIHBvc2l0aW9uIG9mIGluZmxlY3Rpb24gcG9pbnRgKSxtZHgoImxpIix7cGFyZW50TmFtZToib2wifSxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6ImxpIn0sYEFscGhhc2ApLGA6IEhpbGwgZnVuY3Rpb24gKERpbWluaXNoaW5nIHJldHVybnMpIHBhcmFtZXRlciB0aGF0IGNvbnRyb2xzIHRoZSBzaGFwZSBiZXR3ZWVuIGV4cG9uZW50aWFsIGFuZCBzLXNoYXBlYCksbWR4KCJsaSIse3BhcmVudE5hbWU6Im9sIn0sbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJsaSJ9LGBHYW1tYXNgKSxgOiBIaWxsIGZ1bmN0aW9uIChEaW1pbmlzaGluZyByZXR1cm5zKSBwYXJhbWV0ZXIgdGhhdCBjb250cm9scyB0aGUgc2NhbGUgb2YgdHJhbnNmb3JtYXRpb25gKSxtZHgoImxpIix7cGFyZW50TmFtZToib2wifSxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6ImxpIn0sYExhbWJkYXNgKSxgOiBSZWd1bGFyaXphdGlvbiBwZW5hbHR5IHBhcmFtZXRlciBmb3IgcmlkZ2UgcmVncmVzc2lvbmApKSksbWR4KCJsaSIse3BhcmVudE5hbWU6Im9sIn0sbWR4KCJwIix7cGFyZW50TmFtZToibGkifSxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSxgVW5kZXJzdGFuZGluZyBob3cgYWRzdG9jayBhZmZlY3RzIG1lZGlhIHRyYW5zZm9ybWF0aW9uOmApKSxtZHgoIm9sIix7cGFyZW50TmFtZToibGkifSxtZHgoImxpIix7cGFyZW50TmFtZToib2wifSxgSW4gb3JkZXIgdG8gbWFrZSBtb3JlIGluZm9ybWVkIGRlY2lzaW9ucyB0byBkZWZpbmUgaHlwZXJwYXJhbWV0ZXIgdmFsdWVzLCBpdOKAmXMgdmVyeSBoZWxwZnVsIHRvIGtub3cgd2hpY2ggaHlwZXJwYXJhbWV0ZXIgaXMgZG9pbmcgd2hhdCBkdXJpbmcgdGhlIG1lZGlhIHRyYW5zZm9ybWF0aW9uLiBUaGUgcGxvdCBmdW5jdGlvbiBmLnBsb3RBZHN0b2NrQ3VydmVzIGhlbHBzIHlvdSB1bmRlcnN0YW5kIGV4YWN0bHkgdGhhdC5gKSxtZHgoImxpIix7cGFyZW50TmFtZToib2wifSxgQmVsb3cgaXMgdGhlIGdlb21ldHJpYyBhZHN0b2NrIHRoYXQgaXMgYSBvbmUgcGFyYW1ldGVyICh0aGV0YSkgZnVuY3Rpb24uIEFzc3VtZSB0aGUgdGltZSB1bml0IGlzIHdlZWssIHRoZW4gd2UgY2FuIHNlZSB0aGF0IHdoZW4gdGhldGE9MC45LCBtZWFuaW5nIDkwJSBvZiB0aGUgbWVkaWEgZWZmZWN0IHRoaXMgd2VlayBjYXJyaWVzIG92ZXIgdG8gdGhlIG5leHQgd2VlaywgdGhlIGhhbGZsaWZlIGVudGVycyBhZnRlciA4IHdlZWtzIChoYWxmbGlmZSB2YWx1ZSBpbiBsZWdlbmQpLiBJbiBvdGhlciB3b3JkcywgaXQgdGFrZXMgOCB3ZWVrcyB1bnRpbCB0aGUgbWVkaWEgZWZmZWN0IGRlY2F5cyB0byBoYWxmIHdoZW4gdGhldGE9MC45LiBUaGlzIHNob3VsZCBoZWxwIHlvdSBoYXZpbmcgYSBtb3JlIHRhbmdpYmxlIGZlZWxpbmcgYWJvdXQgaWYgdGhlIHRoZXRhIHZhbHVlIGZvciB0aGlzIGNlcnRhaW4gY2hhbm5lbCBtYWtlcyBub3JtYWwgc2Vuc2UuYCkpKSkpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYDxpbWcgYWx0PSJhZHN0b2NraW50cm8gY2hhcnQiIHNyYz17dXNlQmFzZVVybCgnL2ltZy9hZHN0b2NraW50cm8ucG5nJyl9IC8+CmApKSxtZHgoInAiLG51bGwsYFNpbWlsYXIgdG8gYWJvdmUsIHRoaXMgcGxvdCB2aXN1YWxpc2VzIHRoZSB0d28tcGFyYW1ldGVyIChzY2FsZSAmIHNoYXBlKSBXZWlidWxsIGZ1bmN0aW9uLiBUaGUgdXBwZXIgcGxvdCBzaG93cyBjaGFuZ2VzIGluIHNjYWxlIHdoaWxlIGtlZXBpbmcgc2hhcGUgY29uc3RhbnQuIFdlIGNhbiBvYnNlcnZlIHRoYXQgdGhlIGxhcmdlciB0aGUgc2NhbGUsIHRoZSBsYXRlciB0aGUgaW5mbGV4aW9uIHBvaW50LiBXaGVuIHNjYWxlPTAuNSBhbmQgc2hhcGUgPSAyLCBpdCB0YWtlcyAxOCB3ZWVrcyB1bnRpbCB0aGUgbWVkaWEgZWZmZWN0IGRlY2F5cyB0byBoYWxmIChzZWUgbGVnZW5kKS4gVGhlIGxvd2VyIHBsb3Qgc2hvd3MgY2hhbmdlcyBpbiBzaGFwZSB3aGlsZSBrZWVwaW5nIHNjYWxlIGNvbnN0YW50LiBXaGVuIHNoYXBlIGlzIHNtYWxsZXIsIHRoZSBjdXJ2ZSAgcmF0aGVyIHRha2VzIG9uIHRoZSBMLXNoYXBlLiBXaGVuIHNoYXBlIGlzIGxhcmdlciwgdGhlIGN1cnZlIHJhdGhlciB0YWtlcyBvbiBTLXNoYXBlLmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgPGltZyBhbHQ9ImFkc3RvY2tpbnRybzIgY2hhcnQiIHNyYz17dXNlQmFzZVVybCgnL2ltZy9hZHN0b2NraW50cm8yLnBuZycpfSAvPgpgKSksbWR4KCJwIixudWxsLGBJbiBvcmRlciB0byBzdGFydCBzZXR0aW5nIG1vZGVsIHBhcmFtZXRlcnMgd2UgcmVjb21tZW5kIHRvIHN0YXJ0IHdpdGggdGhlIEdlb21ldHJpYyBmdW5jdGlvbi5gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYCMjIHNldCBtb2RlbCBjb3JlIGZlYXR1cmVzCmFkc3RvY2sgPC0gImdlb21ldHJpYyIKYCkpLG1keCgicCIsbnVsbCxgVGhpcyBmdW5jdGlvbiBpcyBzaW1wbGVyIGFuZCB0aGVyZWZvcmUgZWFzaWVyIHRvIHVuZGVyc3RhbmQgY29tcGFyZWQgdG8gdGhlIHdlaWJ1bGwgZnVuY3Rpb24uICBZb3UgbWF5IHN0YXJ0IGJ5IGZvY3VzaW5nIG9uIFRoZXRhc+KAmSBib3VuZHMsIHdoaWNoIGNvbnRyb2xzIGZvciB0aGUgZGVjYXkgcmF0ZSBhbnkgY2hhbm5lbCBjb3VsZCB0YWtlLiBJZiB5b3UgYXJlIG5vdCBzdXJlIGFib3V0IGRlY2F5IHJhdGVzIGZvciB5b3VyIGNoYW5uZWxzLCB3ZSBzdWdnZXN0IHlvdSBzdGFydCB3aXRoIGEgcmFuZ2U6IHRoZXRhcyA9IGMoMCwgMC41KS4gVGhpcyBtZWFucyB0aGF0IGluIGEgd2VlayBieSB3ZWVrIGRhdGFzZXQsIHdlIHdvdWxkIGJlIGV4cGVjdGluZyBhIG1heGltdW0gY2FycnlvdmVyIGVmZmVjdCBvZiA1MCUgb2YgcHJldmlvdXMgd2Vla+KAmXMgdmFsdWVzIHRvIGJlIGV4dGVuZGVkIGFuZCBhZGRlZCB0byB0aGUgZm9sbG93aW5nIHdlZWvigJlzIHZhbHVlcyBmb3IgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSAoU2FsZXMsIGltcHJlc3Npb25zLCBldGMuKWApLG1keCgicCIsbnVsbCxgT25jZSB5b3UgcnVuIG9uZSBvZiB0aGUgaXRlcmF0aW9ucyB5b3UgbWF5IG5vdGljZSB0aGV0YSdzIHZhbHVlcyBhbmQgaWYgY2VydGFpbiBvcHRpbXVtcyBoYXZlIGJlZW4gZm91bmQgYnkgbG9va2luZyBpbnRvIHZhcmlhYmxlcyBpbmNsdWRpbmcgJ3RoZXRhcycgb24gdGhlaXIgbmFtZXMgYW5kIGlkZW50aWZ5aW5nIHRoZSBudW1iZXIgb2YgdGltZXMgYW4gb3B0aW11bSB3YXMgZm91bmQgKGVwb2NoLm9wdGltKS5gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYDxpbWcgYWx0PSJjb2RlcmVzdWx0czEgY2hhcnQiIHNyYz17dXNlQmFzZVVybCgnL2ltZy9jb2RlcmVzdWx0czEucG5nJyl9IC8+CmApKSxtZHgoInAiLG51bGwsYEluIHRoZSBleGFtcGxlIGFib3ZlLCB5b3Ugd2lsbCBzZWUgdGhhdCBGYWNlYm9vayBhbmQgVFYgdGhldGFzIGFyZSBzdGlsbCBtaXNzaW5nIGFuIG9wdGltdW0gZ2l2ZW4gdGhhdCBvcHRpbS5mb3VuZCBjb2x1bW4gaGFzIHN0aWxsIFRSVUUgdmFsdWVzIG9uIGl0LCBmb3IgdGhpcyB3ZSBzdWdnZXN0IHRvIGluY3JlYXNlIGVwb2NoIG51bWJlciB0byBJbmYgKEluZmluaXR5KSB1bnRpbCBhbiBvcHRpbXVtIGlzIGZvdW5kLmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgbW9kZWxfb3V0cHV0IDwtIGYubW1tUm9ieW4oc2V0X2h5cGVyQm91bmRHbG9iYWwKICAgICAgICAgICAgICAgICAgICAgICAgICAsc2V0X2l0ZXIgPSBzZXRfaXRlcgogICAgICAgICAgICAgICAgICAgICAgICAgICxzZXRfY29yZXMgPSBzZXRfY29yZXMKICAgICAgICAgICAgICAgICAgICAgICAgICAsZXBvY2hOID0gSW5mICMgc2V0IHRvIEluZiB0byBhdXRvLW9wdGltaXNlIHVudGlsIG5vIG9wdGltdW0gZm91bmQKICAgICAgICAgICAgICAgICAgICAgICAgICAsb3B0aW0uc2Vuc2l0aXZpdHkgPSAwICMgbXVzdCBiZSBmcm9tIC0xIHRvIDEuIEhpZ2hlciBzZW5zaXRpdml0eSBtZWFucyBmaW5kaW5nIG9wdGltdW0gZWFzaWVyCiAgICAgICAgICAgICAgICAgICAgICAgICAgLHRlbXAuY3N2LnBhdGggPSAnL1VzZXJzL2xlb25lbHNlbnRhbmEvRG9jdW1lbnRzL21tbS50ZW1wb3V0LmNzdicgIyBvdXRwdXQgb3B0aW1pc2F0aW9uIHJlc3VsdCBmb3IgZWFjaCBlcG9jaC4gVXNlIGdldHdkKCkgdG8gZmluZCBwYXRoCiAgICAgICAgICAgICAgICAgICAgICAgICAgKQpgKSksbWR4KCJwIixudWxsLGBCZWxvdyBhbiBleGFtcGxlIHJlYWNoaW5nIG9wdGltdW0gaW4gMzMgZXBvY2hzOmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgPGltZyBhbHQ9ImNvZGVyZXN1bHRzMiBjaGFydCIgc3JjPXt1c2VCYXNlVXJsKCcvaW1nL2NvZGVyZXN1bHRzMi5wbmcnKX0gLz4KYCkpLG1keCgicCIsbnVsbCxgWW91IG1heSBub3RlIGFsbCBwYXJhbWV0ZXJzIHN0YXRlIEZBTFNFIHdoaWNoIG1lYW5zIHRoZXJlIGFyZSBub3QgYW55IG1vcmUgb3B0aW11bXMgdG8gZmluZC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgdmFsdWVzIGZvdW5kIGFyZSBvcHRpbWFsLCBhbmQgdGhhdCBpZiB3YW50ZWQsIHlvdSBjb3VsZCB1c2Ugc29tZSBvZiB0aGVzZSBtb2RlIHZhbHVlcyB0byBmaXggaHlwZXJwYXJhbWV0ZXIgdmFsdWVzIGluIHRoZSAjIyMjIHR1bmUgY2hhbm5lbCBoeXBlcnBhcmFtZXRlcnMgYm91bmRzIHNlY3Rpb24uYCksbWR4KCJoMiIseyJpZCI6InR1bmUtY2hhbm5lbC1oeXBlcnBhcmFtZXRlcnMtYm91bmRzIn0sYFR1bmUgY2hhbm5lbCBoeXBlcnBhcmFtZXRlcnMgYm91bmRzYCksbWR4KCJwIixudWxsLGBGb3IgdGhhdCB5b3Ugd2lsbCBuZWVkIHRvIHNldCB0aGUgZm9sbG93aW5nIGNvbW1hbmQgdG8gVFJVRTpgKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYGFjdGl2YXRlX2h5cGVyQm91bmRMb2NhbFR1bmluZyA8LSBUCmApKSxtZHgoInAiLG51bGwsYFRoaXMgY29tbWFuZCB3aWxsIGVuYWJsZSB5b3UgdG8gZGVmaW5lIHRoZSBib3VuZHMgZWFjaCBtZWRpYeKAmXMgcGFyYW1ldGVyIHNob3VsZCBoYXZlIG1hbnVhbGx5LiBQbGVhc2UgdW5jb21tZW50IHRoZSBmb2xsb3dpbmcgc2VjdGlvbiBvZiB0aGUgY29kZSBhbmQgZGVmaW5lIHRoZSB2YWx1ZXMuIEVhY2ggYm91bmQgY2FuIGJlIGVpdGhlciBhIHJhbmdlIChlLmcgYygwLjEsMC45KSkgb3IgYSBmaXhlZCB2YWx1ZTpgKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYCBzZXRfaHlwZXJCb3VuZExvY2FsIDwtIGxpc3QoCiAgIGZhY2Vib29rX0lfYWxwaGFzID0gYygwLjgzNTYyNzEsIDAuODM3MTc3NCkKICAgLGZhY2Vib29rX0lfZ2FtbWFzID0gYygwLjg5OTE4MTEsIDAuOTAxMjE4MykKICAgLGZhY2Vib29rX0lfdGhldGFzID0gYygwLjg3MDAyODIpCiAgICxvb2hfU19hbHBoYXMgPSBjKDAuODM0ODUwMykKICAgLG9vaF9TX2dhbW1hcyA9IGMoMC4zNTY1NDE3KQogICAsb29oX1NfdGhldGFzID0gYygwLjM4MTUwNTMpCiAgICxwcmludF9TX2FscGhhcyA9IGMoMC42NDkwNTY4KQogICAscHJpbnRfU19nYW1tYXMgPSBjKDAuMTE2NTkxMCwgMC4xMTcxOTUzKQogICAscHJpbnRfU190aGV0YXMgPSBjKDAuNzYxNzM5MCkKICAgLHR2X1NfYWxwaGFzID0gYygyLjQ4ODA0NjApCiAgICx0dl9TX2dhbW1hcyA9IGMoMC44ODY3MTI0KQogICAsdHZfU190aGV0YXMgPSBjKDAuMTQ3Nzk1NCwgMC4xNDc4NTMxKQogICAsc2VhcmNoX2NsaWNrc19QX2FscGhhcyA9IGMoMC4xMzYwNzA4KQogICAsc2VhcmNoX2NsaWNrc19QX2dhbW1hcyA9IGMoMC40MTc3ODAyKQogICAsc2VhcmNoX2NsaWNrc19QX3RoZXRhcyA9IGMoMC41Nzg0Njg1KQogKQpgKSksbWR4KCJwIixudWxsLGBUaGUgaHlwZXJwYXJhbWV0ZXJzIHR1bmluZyBzZWN0aW9uIGlzIGVzcGVjaWFsbHkgaGFuZHkgd2hlbiB3ZSBrbm93IHRoZXJlIGlzIGFuIGV4cGVjdGVkIGJlaGF2aW9yIGJlaGluZCBwYXJhbWV0ZXJzIGUuZy4gYWRzdG9ja2luZyBmb3IgVFYgZGVjYXkgcmF0ZSB0YWtpbmcgb25seSBhIHZhbHVlIHdpdGhpbiBhIHJhbmdlLiBJbiB0aGlzIGNhc2UsIHdlIHdvdWxkIHJlY29tbWVuZCB5b3UgdG8gZ3VpZGUgdGhlIG1vZGVsIHRvd2FyZHMgYSBzb2x1dGlvbiB0aGF0IGlzIGJvdGggb3B0aW1hbCBhbmQgbWVldHMgeW91ciBuZWVkcyBiYXNlZCBvbiBleHBlcmllbmNlIGZyb20gcHJldmlvdXMgYW5hbHlzZXMuYCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGA8aW1nIGFsdD0iY29kZXJlc3VsdHMyIGNoYXJ0IiBzcmM9e3VzZUJhc2VVcmwoJy9pbWcvY29kZXJlc3VsdHMyLnBuZycpfSAvPgpgKSksbWR4KCJwIixudWxsLGBJZiB3ZSBjb25zaWRlciBvdXIgcHJldmlvdXMgZXhhbXBsZSwgaXQgY291bGQgYmUgdGhlIGNhc2Ugd2hlcmUgeW91IG1heSB3YW50IHRvIHR1bmUgVGhldGEgZGVjYXkgcmF0ZXMgdG8gY29udHJvbCBmb3IgdGhlIGFkc3RvY2tpbmcgZGVjYXkgcGFjaW5nIG9mIFRWIHRvIGAsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sYHR2X1NfdGhldGFzID0gYygwLjI1LCAwLjM1KWApLGAuIElmIHdlIGFsc28gZml4IG90aGVyIHZhbHVlcyB3aGVyZSBvcHRpbXVtcyBoYXZlIGJlZW4gcmVhY2hlZCwgd2Ugd291bGQgcmVhY2ggc29tZXRoaW5nIGxpa2UgdGhlIGV4YW1wbGUgYmVsb3cgd2l0aCBmaXggdmFsdWVzIGFuZCByYW5nZXMgYmFzZWQgb24gcHJldmlvdXMgaXRlcmF0aW9ucyBhbmQgcGFzdCBleHBlcmllbmNlOmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgI1BsZWFzZSB1bmNvbW1lbnQgc2V0X2h5cGVyQm91bmRMb2NhbCBsaXN0IGNvbXBsZXRlbHkgYW5kIHVzZSBzY2FsZXMgYW5kIHNoYXBlcyBvbmx5IGlmIHlvdQojaGF2ZSBzZWxlY3RlZCDigJhhZHN0b2NrIDwtICJ3ZWlidWxsIuKAmS4gSWYgeW91IHNlbGVjdGVkIGFkc3RvY2sgPC0gImdlb21ldHJpYyIgYXMgYnkgZGVmYXVsdCwgdGhlbiBzaW1wbHkgI3VzZSBhbHBoYXMsIGdhbW1hcyBhbmQgdGhldGFzIGZvciBlYWNoIGNoYW5uZWwuCgogc2V0X2h5cGVyQm91bmRMb2NhbCA8LSBsaXN0KAogICBmYWNlYm9va19JX2FscGhhcyA9IGMoMC44MzU2MjcxLCAwLjgzNzE3NzQpCiAgICxmYWNlYm9va19JX2dhbW1hcyA9IGMoMC44OTkxODExLCAwLjkwMTIxODMpCiAgICxmYWNlYm9va19JX3RoZXRhcyA9IDAuODcwMDI4MgogICAsb29oX1NfYWxwaGFzID0gMC44MzQ4NTAzCiAgICxvb2hfU19nYW1tYXMgPSAwLjM1NjU0MTcKICAgLG9vaF9TX3RoZXRhcyA9IDAuMzgxNTA1MwogICAscHJpbnRfU19hbHBoYXMgPSAwLjY0OTA1NjgKICAgLHByaW50X1NfZ2FtbWFzID0gYygwLjExNjU5MTAsIDAuMTE3MTk1MykKICAgLHByaW50X1NfdGhldGFzID0gMC43NjE3MzkwCiAgICxzZWFyY2hfY2xpY2tzX1BfYWxwaGFzID0gMC4xMzYwNzA4CiAgICxzZWFyY2hfY2xpY2tzX1BfZ2FtbWFzID0gMC40MTc3ODAyCiAgICxzZWFyY2hfY2xpY2tzX1BfdGhldGFzID0gMC41Nzg0Njg1CiAgICx0dl9TX2FscGhhcyA9IDIuNDg4MDQ2MAogICAsdHZfU19nYW1tYXMgPSAwLjg4NjcxMjQKICAgLHR2X1NfdGhldGFzID0gYygwLjI1LCAwLjM1KQogKQpgKSksbWR4KCJwIixudWxsLGBJZiB3ZSBhcHBseSB0aGUgYWJvdmUgYm91bmRzIHRvIG91ciBtZWRpYSByZWxhdGVkIHZhcmlhYmxlcywgeW91IG1heSBzZWUgdGhhdCByZXN1bHRzIG5vdyByZWFjaCBhbiBvcHRpbXVtIG11Y2ggZmFzdGVyLCBhZnRlciBvbmx5IDIgZXBvY2hzIGluc3RlYWQgb2YgMzMuIFlvdSBtYXkgYWxzbyBvYnNlcnZlIHRoYXQgdGhlIG5ldyBib3VuZHMgZm9yIGAsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sYHR2X1NfdGhldGFzID0gYygwLjI1LCAwLjM1KWApLGAgaGF2ZSBiZWVuIGFwcGxpZWQsIHRoZXJlZm9yZSB0aGUgbmV3IG9wdGltdW0gZm91bmQgaXMgMC4yNzA2MDg1IGluc3RlYWQgb2YgdGhlIDAuMTQ3ODI1NiBmcm9tIHRoZSBwcmV2aW91cyBleGFtcGxlLmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgPGltZyBhbHQ9ImNvZGVyZXN1bHRzMyBjaGFydCIgc3JjPXt1c2VCYXNlVXJsKCcvaW1nL2NvZGVyZXN1bHRzMy5wbmcnKX0gLz4KYCkpLG1keCgiaDIiLHsiaWQiOiJwbG90dGluZy1hbmQtdW5kZXJzdGFuZGluZy1yZXN1bHRzIn0sYFBsb3R0aW5nIGFuZCB1bmRlcnN0YW5kaW5nIHJlc3VsdHNgKSxtZHgoInAiLG51bGwsYFRoZSBmaXJzdCB0aGluZyB5b3Ugd2lsbCBoYXZlIHRvIGRvLCBpcyB0byBzZXQgZXZlcnkgcGxvdCB5b3Ugd291bGQgbGlrZSB0byBiZSBkcmF3biB0byBUUlVFIChUKTpgKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYCMjIyMgUGxvdCBzZWN0aW9uCgojIyBpbnNlcnQgVFJVRSBpbnRvIHBsb3QgZnVuY3Rpb25zIHRvIHBsb3QKZi5wbG90U3BlbmRNb2RlbChGKQpmLnBsb3RIeXBlclNhbXAoRiwgY2hhbm5lbFBsb3QgPSBzZXRfbWVkaWFWYXJOYW1lKSAjIHBsb3QgbGF0aW4gaHlwZXJjdWJlIGh5cGVycGFyYW1ldGVyIHNhbXBsaW5nIGJhbGFuY2UuIE1heC4gMyBjaGFubmVscyBwZXIgcGxvdApmLnBsb3RUcmVuZFNlYXNvbihGKSAjIHBsb3QgcHJvcGhldCB0cmVuZCwgc2Vhc29uIGFuZCBob2xpZGF5IGRlY29tcG9zaXRpb24KYmVzdEFkc3RvY2sgPC0gZi5wbG90TWVkaWFUcmFuc2Zvcm0oVCwgY2hhbm5lbFBsb3QgPSBzZXRfbWVkaWFWYXJOYW1lKSAjIHBsb3QgYmVzdCBtb2RlbCBtZWRpYSB0cmFuc2Zvcm1hdGlvbiB3aXRoIDMgcGxvdHM6IGFkc3RvY2sgZGVjYXkgcmF0ZSwgYWRzdG9jayBlZmZlY3QgJiByZXNwb25zZSBjdXJ2ZS4gTWF4LiAzIGNoYW5uZWxzIHBlciBwbG90CmYucGxvdEJlc3REZWNvbXAoRikgIyBwbG90IGJlc3QgbW9kZWwgZGVjb21wb3NpdGlvbiB3aXRoIDMgcGxvdHM6IHNhbGVzIGRlY29tcCwgYWN0dWFsIHZzIGZpdHRlZCBvdmVyIHRpbWUsICYgc2FsZXMgZGVjb21wIGFyZWEgcGxvdApmLnBsb3RNQVBFQ29udmVyZ2UoRikgIyBwbG90IFJTIE1BUEUgY29udmVyZ2VuY2UsIG9ubHkgZm9yIHJhbmRvbSBzZWFyY2gKZi5wbG90QmVzdE1vZERpYWdub3N0aWMoRikgIyBwbG90IGJlc3QgbW9kZWwgZGlhZ25vc3RpY3M6IHJlc2lkdWFsIHZzIGZpdHRlZCwgUVEgcGxvdCBhbmQgcmVzaWR1YWwgdnMuIGFjdHVhbApmLnBsb3RDaGFubmVsUk9JKEYpCmYucGxvdEh5cENvbnZlcmdlKEYsIGNoYW5uZWxQbG90ID0gc2V0X21lZGlhVmFyTmFtZSkgIyBwbG90IGh5cGVycGFyYW1ldGVyIHZzIE1BUEUgY29udmVyZ2VuY2UuIE1heC4gMyBjaGFubmVscyBwZXIgcGxvdApib3VuZE9wdGltIDwtIGYucGxvdEh5cGVyQm91bmRPcHRpbShGLCBjaGFubmVsUGxvdCA9IHNldF9tZWRpYVZhck5hbWUsIG1vZGVsX291dHB1dCwga3VydC50dW5lciA9IG9wdGltLnNlbnNpdGl2aXR5KSAgIyBpbXByb3ZlZCBoeXBlcnBhcmFtZXRlciBwbG90IHRvIGJldHRlciB2aXN1YWxpc2UgdHJlbmRzIGluIGVhY2ggaHlwZXJwYXJhbWV0ZXIKYCkpLG1keCgicCIsbnVsbCxgQWZ0ZXIgdGhhdCwgeW91IG1heSBleGVjdXRlIGVhY2ggcGxvdCBzZXBhcmF0ZWx5IGFuZCBhbmFseXplIGl0LmApLG1keCgiaDMiLHsiaWQiOiJmcGxvdHNwZW5kbW9kZWwtcGxvdHRpbmctdGhlLXNwZW5kLXJlYWNoLWZpdHRpbmctd2l0aC1taWNoYWVsaXMtbWVudGVuLW1vZGVsIn0sYGYucGxvdFNwZW5kTW9kZWw6IFBsb3R0aW5nIHRoZSBzcGVuZC1yZWFjaCBmaXR0aW5nIHdpdGggTWljaGFlbGlzLU1lbnRlbiBtb2RlbGApLG1keCgicCIsbnVsbCxgVGhlIHBsb3QgYmVsb3cgaWxsdXN0cmF0ZXMgaG93IHRvIGJldHRlciB0cmFuc2xhdGUgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHNwZW5kIGFuZCByZWFjaCBzbyB0aGF0IHlvdSBjYW4gYXBwbHkgaXQgdG8gcGVyZm9ybWFuY2UgUk9JIChSZXZlbnVlL3NwZW5kKSBjYWxjdWxhdGlvbnMuIEl0IGlzIHBvc3NpYmxlIHRvIGNob29zZSByZWFjaCB2YXJpYWJsZXMgKEdSUCwgaW1wcmVzc2lvbnMsIGFjdHVhbCByZWFjaCwgZXRjLikgaW4gdGhlIG1vZGVsLiBVbmRlcnN0YW5kaW5nIHRoYXQgcmVsYXRpb25zaGlwIGNhbiBoZWxwIHdpdGggdGhlIHRyYW5zbGF0aW9uIG9mIHJlYWNoIHRvIHNwZW5kIGFuZCB2aWNlIHZlcnNhLgpMTSAoTGluZWFyIE1vZGVsKSBhbmQgTkxTIChOb24tbGluZWFyIGxlYXN0IHNxdWFyZXMpIGNvbXBhcmlzb24gc2hvd3Mgd2h5IGl0IGlzIGJldHRlciB0byB1c2UgYSBub24tbGluZWFyIG1vZGVsLCB3aGljaCBpcyB0aGUgdGVjaG5pcXVlIGFwcGxpZWQgaW4gdGhlIGNvZGUuIFRoZSBsaW5lYXIgbW9kZWwgaXMgYWN0dWFsbHkgYXMgcHJpbWl0aXZlIGFzIGp1c3QgdXNpbmcgYXZlcmFnZSB0byBzY2FsZSwgYmVjYXVzZSBpbiBvdXIgY2FzZSB0aGUgaW50ZXJjZXB0IGlzIG9taXR0ZWQgZ2l2ZW4gdGhhdCB3ZSBhc3N1bWUgbm8gc3BlbmQgaW52b2x2ZXMgbm8gcmVhY2guIFdoZXJlYXMgTkxTIGFyZSBtb3JlIGZsZXhpYmxlIGFuZCBzaG91bGQgYWRhcHQgYmV0dGVyIHRvIHRoZSB1bmRlcmx5aW5nIGNvcnJlbGF0aW9uIHBhdHRlcm5zIGJldHdlZW4gYm90aCB2YXJpYWJsZXMuYCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGA8aW1nIGFsdD0icGxvdFNwZW5kTW9kZWwgY2hhcnQiIHNyYz17dXNlQmFzZVVybCgnL2ltZy9wbG90U3BlbmRNb2RlbC5wbmcnKX0gLz4KYCkpLG1keCgiaDMiLHsiaWQiOiJmcGxvdGh5cGVyc2FtcC1jaGVja2luZy1sYXRpbi1oeXBlcmN1YmUtc2FtcGxpbmctZGlzdHJpYnV0aW9uIn0sYGYucGxvdEh5cGVyU2FtcDogY2hlY2tpbmcgbGF0aW4gaHlwZXJjdWJlIHNhbXBsaW5nIGRpc3RyaWJ1dGlvbmApLG1keCgicCIsbnVsbCxgVGhlIG92ZXJhbGwgaWRlYSBvZiB0aGVzZSBjaGFydHMgaXMgdG8gdmFsaWRhdGUgdGhlIGAsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sYExhdGluIGh5cGVyY3ViZSBzYW1wbGluZyAoTEhTKWApLGAsIHdoaWNoIGlzIGEgc3RhdGlzdGljYWwgbWV0aG9kIGZvciBnZW5lcmF0aW5nIGEgbmVhci1yYW5kb20gc2FtcGxlIG9mIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgbXVsdGlkaW1lbnNpb25hbCBkaXN0cmlidXRpb24gb2YgaHlwZXJwYXJhbWV0ZXJzLiBJdCBjb25zaXN0cyBvZiB0d28gbWFpbiBjaGFydHM6YCksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6ImxpIn0sYExhdGluIEh5cGVyY3ViZSBTYW1wbGluZyBkaXN0cmlidXRpb246YCksYCBUaGUga2V5IGFzcGVjdCBpcyB0byBjb25jZW50cmF0ZSBvbiB0aGUgcmFuZG9tbmVzcyBvZiB0aGUgcG9pbnRzIG9uIHRoaXMgY2hhcnQuIElmIGFsbCBkb3RzIHNlZW0gdG8gY292ZXIgZXZlbmx5IHRoZSBzcGFjZSBhcyBpbiB0aGUgZXhhbXBsZSBiZWxvdywgdGhlbiBzYW1wbGluZyBpcyBvay4gSG93ZXZlciwgYmV3YXJlIG9mIGhpZ2ggY29uY2VudHJhdGlvbnMgb2YgZG90cyBvciBjbGVhciBhcmVhcyB3aXRob3V0IGFueSBkb3RzIHdoaWNoIG1heSBtZWFuIHlvdSB3aWxsIGhhdmUgdG8gaW5jcmVhc2UgdGhlIHNhbXBsaW5nIHRvIGhhdmUgYSBiZXR0ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGh5cGVyc3BhY2UuYCksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJsaSJ9LGBMYXRpbiBIeXBlcmN1YmUgU2FtcGxpbmcgZGlzdHJpYnV0aW9uIHRyYW5zZm9ybWVkOmApLGAgVGhpcyBpcyBhIGhhbGYgdmlvbGluIGNoYXJ0IHRoYXQgcmVwcmVzZW50cyB0aGUgZGlzdHJpYnV0aW9uIG9mIGVhY2ggbWVkaWEgcGFyYW1ldGVyIHZhbHVlcy4gSXQgaGVscHMgeW91IHVuZGVyc3RhbmQgdGhlIGFjdHVhbCByYW5nZSBvZiB2YWx1ZXMgdGhhdCBlYWNoIHBhcmFtZXRlciBpcyB0YWtpbmcgaW4gb3JkZXIgdG8gcmVwcmVzZW50IHVuaWZvcm1seSB0aGUgaHlwZXJwYXJhbWV0ZXIgc3BhY2UuIEl0IHdpbGwgYWxzbyBkZXBlbmQgb24gdGhlIHNldF9oeXBlckJvdW5kR2xvYmFsIHZhcmlhYmxlIGFuZCBpdHMgYm91bmQgZGVmaW5pdGlvbnMuYCkpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgPGltZyBhbHQ9InBsb3RIeXBlclNhbXAgY2hhcnQiIHNyYz17dXNlQmFzZVVybCgnL2ltZy9wbG90SHlwZXJTYW1wLnBuZycpfSAvPgpgKSksbWR4KCJoMyIseyJpZCI6ImZwbG90dHJlbmRzZWFzb24tdW5kZXJzdGFuZGluZy10cmVuZC1hbmQtc2Vhc29uYWxpdHkifSxgZi5wbG90VHJlbmRTZWFzb246IFVuZGVyc3RhbmRpbmcgdHJlbmQgYW5kIHNlYXNvbmFsaXR5YCksbWR4KCJwIixudWxsLGBUaGlzIHBsb3QgZGVzY3JpYmVzIHRoZSB0cmVuZCwgaG9saWRheXMgYW5kIHNlYXNvbmFsaXR5IGFsb25nIHRoZSBhbmFseXplZCBwZXJpb2QuYCksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxgVGhlIGAsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJsaSJ9LGB0cmVuZGApLGAgaXMgdGhlIGNvbXBvbmVudCBvZiBhIHRpbWUgc2VyaWVzIHRoYXQgcmVwcmVzZW50cyBsb3cgZnJlcXVlbmN5IHZhcmlhdGlvbnMgaW4gdGltZS4gSXQgcmVmbGVjdHMgdGhlIHVuZGVybHlpbmcgdGVuZGVuY3kgYmVoaW5kIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgd2hpY2ggY2FuIHJlZmxlY3QgZ3Jvd3RoLCBzdGFiaWxpdHkgb3Igc2hyaW5rYWdlIGRlcGVuZGluZyBvbiB0aGUgdGltZSB1bml0IGFuYWx5emVkLmApLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgic3Ryb25nIix7cGFyZW50TmFtZToibGkifSxgSG9saWRheXNgKSxgIGFyZSBiYXNpY2FsbHkgZGF5cyBkZWZpbmVkIGJ5IGdvdmVybm1lbnRzIHdoZXJlIHBlb3BsZSBjb21tZW1vcmF0ZSBldmVudHMgd2hpY2ggY2FuIGFmZmVjdCBjb25zdW1wdGlvbiBiZWhhdmlvcnMuIFNvbWUgaG9saWRheXMgbWF5IGhhdmUgbW9yZSBpbXBhY3QgdGhhbiBvdGhlcnMsIHRoZXJlZm9yZSB0aGUgZGlmZmVyZW50IG1hZ25pdHVkZXMgb24gdGhlIGNoYXJ0LmApLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgic3Ryb25nIix7cGFyZW50TmFtZToibGkifSxgU2Vhc29uYWxpdHlgKSxgIGlzIGEgY2hhcmFjdGVyaXN0aWMgb2YgYSB0aW1lIHNlcmllcyBpbiB3aGljaCB0aGUgdGltZSBzZXJpZXMgZXhwZXJpZW5jZXMgcmVndWxhciBhbmQgcHJlZGljdGFibGUgY2hhbmdlcyB0aGF0IHJlY3VyIGV2ZXJ5IGNhbGVuZGFyIHllYXIuIEFueSBwcmVkaWN0YWJsZSBmbHVjdHVhdGlvbiBvciBwYXR0ZXJuIHRoYXQgcmVjdXJzIG9yIHJlcGVhdHMgb3ZlciBhIG9uZS15ZWFyIHBlcmlvZCBpcyBzYWlkIHRvIGJlIHNlYXNvbmFsLiBCZWxvdyB3ZSBoYXZlIHRoZSB5ZWFybHkgc2Vhc29uYWxpdHkgYXMgYW4gZXhhbXBsZSwgd2hpY2ggc2hvd3MgaGlnaGVyIGRlbWFuZCBiZXR3ZWVuIE9jdG9iZXIgYW5kIERlY2VtYmVyLCBhbmQgbG93ZXIgZGVtYW5kIGJldHdlZW4gQXByaWwgYW5kIEp1bHkuYCkpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgPGltZyBhbHQ9InBsb3RUcmVuZFNlYXNvbiBjaGFydCIgc3JjPXt1c2VCYXNlVXJsKCcvaW1nL3Bsb3RUcmVuZFNlYXNvbi5wbmcnKX0gLz4KYCkpLG1keCgiaDMiLHsiaWQiOiJiZXN0YWRzdG9jay1hZHN0b2NrLWNhcnJ5b3Zlci1hbmQtZGltaW5pc2hpbmctcmV0dXJucy1lZmZlY3RzIn0sYGJlc3RBZHN0b2NrOiBBZHN0b2NrIGNhcnJ5b3ZlciBhbmQgZGltaW5pc2hpbmcgcmV0dXJucyBlZmZlY3RzYCksbWR4KCJwIixudWxsLGBUaGlzIHBsb3QgcmVwcmVzZW50cyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gc3BlbmQgb3IgUk9JLCBhbmQgdGhlIHJlc3BvbnNlIHZhcmlhYmxlIChTYWxlcywgY29udmVyc2lvbnMsIGV0Yy4pLgpPbiB0aGUgZmlyc3QgbGluZSBvZiBjaGFydHMgeW91IHdpbGwgZmluZDoKVGhlIHJlc3BvbnNlIGN1cnZlIHdoaWNoIGNhbiBiZSBTIG9yIEMgbGlrZSwgaXRzIHNjYWxlIG9mIGdyb3d0aCBhbmQgZGltaW5pc2hpbmcgcmV0dXJucyBwYWNlLgpUaGUgcHJvZml0IGN1cnZlIHdoaWNoIGlsbHVzdHJhdGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIFkgYW5kIFggYXhlcyAoUmVzcG9uc2UtcHJvZml0KS4gVGhlIGhpZ2hlciB0aGlzIGN1cnZlIGlzIG9uIHRoZSBZIGF4aXMsIHRoZSBjbG9zZXIgdG8gYSBtYXggcHJvZml0IHBvaW50IHlvdSB3aWxsIGdldC4KVGhlIHNlY29uZCBsaW5lIG9mIGNoYXJ0cyBkaXNwbGF5cyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gUk9JIGFuZCBzcGVuZCwgdGhlIGhpZ2hlciB0aGUgY3VydmUgb24gdGhlIFkgYXhpcywgdGhlIGdyZWF0ZXIgdGhlIHJlc3BvbnNlIG9idGFpbmVkLiBNYXhpbXVtIGFuZCBBdmVyYWdlIFJPSSBhcmUgZHJhd24gZm9yIGFuIGVhc2llciByZWFkLmApLG1keCgicCIsbnVsbCxgTm90ZTogVGhpcyBwbG90IGFkbWl0cyBvbmx5IDMgY2hhbm5lbHMgYXQgYSB0aW1lLiBQbGVhc2Ugc2VsZWN0IHRoZSAzIGNoYW5uZWxzIHlvdSB3b3VsZCBsaWtlIHRvIGFuYWx5emUgYXMgaW4gdGhlIGV4YW1wbGUgYmVsb3cgd2hlcmUgZmlyc3Qgd2UgbG9vayBhdCBjaGFubmVsIG5hbWVzLCBhbmQgc2Vjb25kLCB3ZSBpbmRpY2F0ZSB3aGljaCBuYW1lcyB3aXRoaW4gc2V0X21lZGlhVmFyTmFtZSBvYmplY3QgdG8gcGxvdCBjKDEsMiw1KSA6YCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGBzZXRfbWVkaWFWYXJOYW1lCmJlc3RBZHN0b2NrIDwtIGYucGxvdE1lZGlhVHJhbnNmb3JtKFQsIGNoYW5uZWxQbG90ID0gc2V0X21lZGlhVmFyTmFtZVtjKDEsMiw1KV0pCmApKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYDxpbWcgYWx0PSJiZXN0QWRzdG9jayBjaGFydCIgc3JjPXt1c2VCYXNlVXJsKCcvaW1nL2Jlc3RBZHN0b2NrLnBuZycpfSAvPgpgKSksbWR4KCJoMyIseyJpZCI6ImZwbG90YmVzdGRlY29tcC11bmRlcnN0YW5kaW5nLXRoZS1lZmZlY3Qtb2YtYmFzZWxpbmUtbWVkaWEtdmFyaWFibGVzLXRyZW5kLWFuZC1zZWFzb25hbGl0eS1hbG9uZy10aW1lIn0sYGYucGxvdEJlc3REZWNvbXA6IFVuZGVyc3RhbmRpbmcgdGhlIGVmZmVjdCBvZiBiYXNlbGluZSwgbWVkaWEgdmFyaWFibGVzIHRyZW5kIGFuZCBzZWFzb25hbGl0eSBhbG9uZyB0aW1lYCksbWR4KCJwIixudWxsLGBUaGUgYWltIG9mIHRoaXMgY2hhcnQgaXMgdG8gZGlzcGxheSB0aGUgYnJlYWtkb3duIG9mIHRoZSByZXNwb25zZSB2YXJpYWJsZSB0aHJvdWdoIHRpbWUgYW5kIHRoZSByZWxhdGlvbnNoaXAgd2l0aCBlYWNoIG9mIGl0cyByZWdyZXNzaW5nIGNvbXBvbmVudHMuIEFzIHdpdGggYWxsIG1hcmtldGluZyBtaXggbW9kZWxzLCBib3RoIG1lZGlhIGFuZCBub24tbWVkaWEgcmVsYXRlZCBleHBsYW5hdG9yeSBmYWN0b3JzIGFyZSBkaXNwbGF5ZWQsIGluY2x1ZGluZyBiYXNlbGluZSBlZmZlY3RzIHN1Y2ggYXMgcHJpY2UgYW5kIHByb21vdGlvbnMsIGFzIHdlbGwgYXMsIHRyZW5kICwgc2Vhc29uYWxpdHkgYW5kIGhvbGlkYXlzLiBJbiBvcmRlciB0byBiZSBhYmxlIHRvIG1ha2UgYSBwcm9wZXIgZGVzY3JpcHRpb24gYW5kIGZvcmVjYXN0IG9mIHBlcmZvcm1hbmNlLCB3ZSBtdXN0IGtub3cgdG8gd2hhdCBleHRlbnQgZWFjaCBjb21wb25lbnQgaXMgcHJlc2VudCBpbiB0aGUgZGF0YS5gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYDxpbWcgYWx0PSJwbG90QmVzdERlY29tcCBjaGFydCIgc3JjPXt1c2VCYXNlVXJsKCcvaW1nL3Bsb3RCZXN0RGVjb21wLnBuZycpfSAvPgpgKSksbWR4KCJwIixudWxsLGBUaGUgY2hhcnQgYmVsb3cgaWxsdXN0cmF0ZXMgdGhlIGNvbnRyaWJ1dGlvbiBvZiBlYWNoIHJlZ3Jlc3NvciB2YXJpYWJsZSB0byB0aGUgb3ZlcmFsbCByZXNwb25zZSAoU2FsZXMgaW4gdGhpcyBjYXNlKSBZb3UgbWF5IGZpbmQgZm9yIGV4YW1wbGUgdGhhdCBGYWNlYm9vayBpbXByZXNzaW9ucyBoYWQgYSA3LjYlIGNvbnRyaWJ1dGlvbiB0byBvdmVyYWxsIHNhbGVzIHdoaWNoIHJlcHJlc2VudCBpbiB0b3RhbCAkMjguOCBtaWxsaW9uLmApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgPGltZyBhbHQ9ImJlc3REZWNvbXAyIGNoYXJ0IiBzcmM9e3VzZUJhc2VVcmwoJy9pbWcvYmVzdERlY29tcDIucG5nJyl9IC8+CmApKSxtZHgoInAiLG51bGwsYFRoZSBuZXh0IGNoYXJ0IHNob3dzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcmVhbCBhbmQgcHJlZGljdGVkIHZhbHVlcy4gVGhlIGNsb3NlciB0aGUgbGluZXMgZm9yIHkgYW5kIHlfcHJlZCwgdGhlIGJldHRlci4gWW91IG1heSBhbHNvIGZpbmQgUlNRIGFuZCBNQVBFIG1ldHJpY3MuIFJTUSBvciBSLXNxdWFyZWQgKFIyKSBpcyBhIHN0YXRpc3RpY2FsIG1lYXN1cmUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wb3J0aW9uIG9mIHRoZSB2YXJpYW5jZSBmb3IgYSBkZXBlbmRlbnQgdmFyaWFibGUgdGhhdCBpcyBleHBsYWluZWQgYnkgYW4gaW5kZXBlbmRlbnQgdmFyaWFibGUgb3IgdmFyaWFibGVzIGluIGEgcmVncmVzc2lvbiBtb2RlbC4gSW4gZ2VuZXJhbCB0ZXJtcywgdGhlIGNsb3NlciB0byBvbmUsIHRoZSBiZXR0ZXIuICBXaGVyZWFzLCB0aGUgbWVhbiBhYnNvbHV0ZSBwZXJjZW50YWdlIGVycm9yIChNQVBFKSBpcyB0aGUgbWVhbiBvciBhdmVyYWdlIG9mIHRoZSBhYnNvbHV0ZSBwZXJjZW50YWdlIGVycm9ycyBvZiBmb3JlY2FzdHMuIEVycm9yIGlzIGRlZmluZWQgYXMgYWN0dWFsIG9yIG9ic2VydmVkIHZhbHVlIG1pbnVzIHRoZSBmb3JlY2FzdGVkIHZhbHVlLiBBcyBhIGdlbmVyYWwgcnVsZSwgdGhlIGNsb3NlciB0byB6ZXJvIHRoZSBiZXR0ZXIuYCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGA8aW1nIGFsdD0iYmVzdERlY29tcDMgY2hhcnQiIHNyYz17dXNlQmFzZVVybCgnL2ltZy9iZXN0RGVjb21wMy5wbmcnKX0gLz4KYCkpLG1keCgiaDMiLHsiaWQiOiJmcGxvdG1hcGVjb252ZXJnZS11bmRlcnN0YW5kaW5nLW1hcGUtZXZvbHV0aW9uLXBlci1yYW5kb20tc2VhcmNoLWl0ZXJhdGlvbi1hbmQtbWludXRlcy1zcGVudCJ9LGBmLnBsb3RNQVBFQ29udmVyZ2U6IFVuZGVyc3RhbmRpbmcgTUFQRSBldm9sdXRpb24gcGVyIFJhbmRvbSBTZWFyY2ggaXRlcmF0aW9uIGFuZCBtaW51dGVzIHNwZW50YCksbWR4KCJwIixudWxsLGBUaGUgY2hhcnQgYmVsb3cgZGlzcGxheXMgdGhlIGV2b2x1dGlvbiBvZiB0aGUgbWVhbiBhYnNvbHV0ZSBwZXJjZW50YWdlIGVycm9yIChNQVBFKSB3aXRoIGV2ZXJ5IG1pbnV0ZSBzcGVudCBvbiBjb21wdXRpbmcuIFRoaXMgY2hhcnQgd2lsbCBoZWxwIHlvdSB1bmRlcnN0YW5kIGhvdyBtYW55IHJhbmRvbSBzZWFyY2ggaXRlcmF0aW9ucyB0byBpbmNsdWRlIGluIHRoZSBtb2RlbCB1bmRlciBgLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LGBzZXRfaXRlcmApLGAgdmFyaWFibGUuIElmIHlvdSBpbmNyZWFzZSBzZXRfaXRlciBmcm9tIDEwMCB0byAxMDAwMCwgeW91IHdpbGwgcmVhY2ggYSBwb2ludCB3aGVyZSBNQVBFIHdpbGwgbm90IGRlY3JlYXNlIGluIHRpbWUuIFRoZXJlZm9yZSwgZmluZGluZyB0aGUgb3B0aW11bSBtYXkgYmUgYmV0d2VlbiAxMDAgYW5kIDEwMDAwIG1heSBiZSB5b3VyIG5leHQgc3RlcCB1bnRpbCB5b3UgZmluZCB0aGUgYmFsYW5jZSBiZXR3ZWVuIGNvbXB1dGluZyB0aW1lIGFuZCBNQVBFIHJlZHVjdGlvbi5gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYDxpbWcgYWx0PSJwbG90TUFQRUNvbnZlcmdlIGNoYXJ0IiBzcmM9e3VzZUJhc2VVcmwoJy9pbWcvcGxvdE1BUEVDb252ZXJnZS5wbmcnKX0gLz4KYCkpLG1keCgiaDMiLHsiaWQiOiJmcGxvdGJlc3Rtb2RkaWFnbm9zdGljLXBsb3QtYmVzdC1tb2RlbC1kaWFnbm9zdGljcy1yZXNpZHVhbC12cy1maXR0ZWQtcXEtcGxvdC1hbmQtcmVzaWR1YWwtdnMtYWN0dWFsIn0sYGYucGxvdEJlc3RNb2REaWFnbm9zdGljOiBwbG90IGJlc3QgbW9kZWwgZGlhZ25vc3RpY3M6IHJlc2lkdWFsIHZzIGZpdHRlZCwgUVEgcGxvdCBhbmQgcmVzaWR1YWwgdnMuIGFjdHVhbGApLG1keCgicCIsbnVsbCxgQWNyb3NzIHRoZXNlIHBsb3RzIHdlIGFuYWx5emUgcmVzaWR1YWxzLCB3aGljaCBhcmUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgb2JzZXJ2ZWQgdmFsdWUgb2YgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSAoeSkgYW5kIHRoZSBwcmVkaWN0ZWQgdmFsdWUgKMW3KS5gKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgicCIse3BhcmVudE5hbWU6ImxpIn0sbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sYEZpdHRlZCB2cy4gUmVzaWR1YWw6YCksYCBXaGVuIGNvbmR1Y3RpbmcgYSByZXNpZHVhbCBhbmFseXNpcywgYSAicmVzaWR1YWxzIHZlcnN1cyBmaXR0ZWQgcGxvdCIgaXMgdGhlIG1vc3QgZnJlcXVlbnRseSBjcmVhdGVkIHBsb3QuIEl0IGlzIGEgc2NhdHRlciBwbG90IG9mIHJlc2lkdWFscyBvbiB0aGUgeSBheGlzIGFuZCBmaXR0ZWQgdmFsdWVzIChlc3RpbWF0ZWQgcmVzcG9uc2VzKSBvbiB0aGUgeCBheGlzLiBUaGUgcGxvdCBpcyB1c2VkIHRvIGRldGVjdCBub24tbGluZWFyaXR5LCB1bmVxdWFsIGVycm9yIHZhcmlhbmNlcywgYW5kIG91dGxpZXJzLiBUaGUgbW9yZSByYW5kb20gdGhlIHBhdHRlcm4gZm9yIHRoZSBkb3RzIGRpc3RyaWJ1dGlvbiBpbiB0aGlzIHBsb3QgYW5kIHRoZSBtb3JlIGhvcml6b250YWwgdGhlIHNtb290aCBsaW5lLCB0aGUgYmV0dGVyLCBhcyBpdCB3b3VsZCBtZWFuIGxpbmVhcml0eSwgaW5kZXBlbmRlbnQgZXJyb3IgdmFyaWFuY2VzIGFuZCBhYnNlbmNlIG9mIG91dGxpZXJzLmApKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxtZHgoInAiLHtwYXJlbnROYW1lOiJsaSJ9LG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LGBRUSBQbG90OmApLGAgVGhlIHF1YW50aWxlLXF1YW50aWxlIChxLXEpIHBsb3QgaXMgYSBncmFwaGljYWwgdGVjaG5pcXVlIHRvIGRldGVybWluZSBpZiB0d28gZGF0YSBzZXRzIGNvbWUgZnJvbSBwb3B1bGF0aW9ucyB3aXRoIGEgY29tbW9uIGRpc3RyaWJ1dGlvbi4gQSBxLXEgcGxvdCBpcyBhIHBsb3Qgb2YgdGhlIHF1YW50aWxlcyBvZiB0aGUgZmlyc3QgZGF0YSBzZXQgYWdhaW5zdCB0aGUgcXVhbnRpbGVzIG9mIHRoZSBzZWNvbmQgZGF0YSBzZXQgaW4gdGhpcyBjYXNlIG9ic2VydmVkIFkgYW5kIFlfcHJlZC4gQSA0NS1kZWdyZWUgcmVmZXJlbmNlIGxpbmUgaXMgYWxzbyBwbG90dGVkLiBUaGUgY2xvc2VyIHRoZSBkb3RzIHRvIHRoZSA0NSBkZWdyZWVzIGxpbmUsIHRoZSBiZXR0ZXIuYCkpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgicCIse3BhcmVudE5hbWU6ImxpIn0sbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sYE9ic2VydmVkIHZzLiBSZXNpZHVhbDpgKSxgIENvbXBhcmVkIHRvIHRoZSBGaXR0ZWQgdnMuIFJlc2lkdWFsIHBsb3QsIHRoaXMgcGxvdCBzaG93cyBtb3JlIGNvcnJlbGF0aW9uIGJldHdlZW4gb2JzZXJ2ZWQvdHJ1ZSByZXNwb25zZSB2cy4gcmVzaWR1YWxzIHdoZW4gdGhlIG1vZGVsIFIyIGlzIGxvd2VyLiBOb3JtYWxseSwgYSBjZXJ0YWluIGRlZ3JlZSBvZiBjb3JyZWxhdGlvbiBoZXJlIG1lYW5zIGVpdGhlciB0aGUgZGF0YSBpcyBqdXN0IG5vaXN5IG9yIHRoZXJl4oCZcyBzdGlsbCBtaXNzaW5nIHBhdHRlcm5zIHdpdGhpbiB0aGUgZXJyb3IuIEluIHRoZSBjb250ZXh0IG9mIE1NTSwgd2Ugd291bGQgcmVjb21tZW5kIHRvIGFzc3VtZSB0aGUgbGF0dGVyIG9uZSBhbmQgbG9vayBmb3IgcG90ZW50aWFsIGFkZGl0aW9uYWwgcHJlZGljdG9ycyB0byBhbHNvIGNhcHR1cmUgdGhlc2UgcGF0dGVybnMuCldoZW4gY29uZHVjdGluZyBhIHJlc2lkdWFsIGFuYWx5c2lzLCBhICJyZXNpZHVhbHMgdmVyc3VzIG9ic2VydmVkIHBsb3QiIGlzIGNvbW1vbmx5IHVzZWQgYXMgYSBjb21wbGVtZW50IG9mIHJlc2lkdWFsIHZzLiBmaXR0ZWQgcGxvdHMuIEl0IGlzIGEgc2NhdHRlciBwbG90IG9mIHJlc2lkdWFscyBvbiB0aGUgeSBheGlzIGFuZCBvYnNlcnZlZCB2YWx1ZXMgKEFjdHVhbCByZXNwb25zZXMpIG9uIHRoZSB4IGF4aXMuIFRoZSBwbG90IGlzIHVzZWQgdG8gZGV0ZWN0IG5vbi1saW5lYXJpdHksIHVuZXF1YWwgZXJyb3IgdmFyaWFuY2VzLCBhbmQgb3V0bGllcnMuIFRoZSBtb3JlIHVuaWZvcm0gdGhlIGRvdHMgZGlzdHJpYnV0aW9uIGluIHRoaXMgcGxvdCBhbmQgdGhlIG1vcmUgaG9yaXpvbnRhbCB0aGUgc21vb3RoIGxpbmUsIHRoZSBiZXR0ZXIgYXMgaXQgd291bGQgbWVhbiBpbmRlcGVuZGVudCBlcnJvciB2YXJpYW5jZXMgYW5kIGFic2VuY2Ugb2Ygb3V0bGllcnMuIFRoZSBjb250cmFzdCBiZXR3ZWVuIGZpdHRlZCBhbmQgb2JzZXJ2ZWQgdnMuIHJlc2lkdWFsIGNoYXJ0cyBoZWxwcyB0byB1bmRlcnN0YW5kIGlmIHRoZXJlIGFyZSBjb21tb24gcmVsYXRpb25zaGlwcyBiZXR3ZWVuIGJvdGggYW5kIHJlc2lkdWFscy5gKSkpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgPGltZyBhbHQ9ImYucGxvdEJlc3RNb2REaWFnbm9zdGljIGNoYXJ0IiBzcmM9e3VzZUJhc2VVcmwoJy9pbWcvZi5wbG90QmVzdE1vZERpYWdub3N0aWMucG5nJyl9IC8+CmApKSk7fTtNRFhDb250ZW50LmlzTURYQ29tcG9uZW50PXRydWU7"},{"version":3,"sources":["/Users/leonelsentana/Robyn/docs/docs/doc12.md"],"names":["React","mdx","frontMatter","id","title","metadata","rightToc","value","children","layoutProps","MDXLayout","MDXContent","components","props","isMDXComponent"],"mappings":"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","sourcesContent":["\n  import React from 'react';\n  import { mdx } from '@mdx-js/react';\n\n  export const frontMatter = {\n\tid: 'doc12',\n\ttitle: 'Step-by-step guide'\n};\nexport const metadata = {\n  \"unversionedId\": \"doc12\",\n  \"id\": \"doc12\",\n  \"isDocsHomePage\": false,\n  \"title\": \"Step-by-step guide\",\n  \"description\": \"Load data & scripts\",\n  \"source\": \"@site/docs/doc12.md\",\n  \"permalink\": \"/Robyn/docs/doc12\",\n  \"editUrl\": \"https://github.com/facebookexperimental/Robyn/docs/doc12.md\",\n  \"sidebar\": \"someSidebar\",\n  \"previous\": {\n    \"title\": \"Quick Start\",\n    \"permalink\": \"/Robyn/docs/doc3\"\n  },\n  \"next\": {\n    \"title\": \"Ridge Regression\",\n    \"permalink\": \"/Robyn/docs/doc4\"\n  }\n};\n  /* @jsx mdx */\n\nexport const rightToc = [{\n  value: 'Load data &amp; scripts',\n  id: 'load-data--scripts',\n  children: []\n}, {\n  value: 'Set model input variables',\n  id: 'set-model-input-variables',\n  children: [{\n    value: 'set_country',\n    id: 'set_country',\n    children: []\n  }, {\n    value: 'set_dateVarName',\n    id: 'set_datevarname',\n    children: []\n  }, {\n    value: 'set_depVarName and set_depVarType',\n    id: 'set_depvarname-and-set_depvartype',\n    children: []\n  }, {\n    value: 'Set Prophet variables',\n    id: 'set-prophet-variables',\n    children: []\n  }, {\n    value: 'Set Baseline variables',\n    id: 'set-baseline-variables',\n    children: []\n  }, {\n    value: 'set_mediaVarName and set_mediaSpendName',\n    id: 'set_mediavarname-and-set_mediaspendname',\n    children: []\n  }, {\n    value: 'Set factor variables',\n    id: 'set-factor-variables',\n    children: []\n  }]\n}, {\n  value: 'Set global model parameters',\n  id: 'set-global-model-parameters',\n  children: []\n}, {\n  value: 'Tune channel hyperparameters bounds',\n  id: 'tune-channel-hyperparameters-bounds',\n  children: []\n}, {\n  value: 'Plotting and understanding results',\n  id: 'plotting-and-understanding-results',\n  children: [{\n    value: 'f.plotSpendModel: Plotting the spend-reach fitting with Michaelis-Menten model',\n    id: 'fplotspendmodel-plotting-the-spend-reach-fitting-with-michaelis-menten-model',\n    children: []\n  }, {\n    value: 'f.plotHyperSamp: checking latin hypercube sampling distribution',\n    id: 'fplothypersamp-checking-latin-hypercube-sampling-distribution',\n    children: []\n  }, {\n    value: 'f.plotTrendSeason: Understanding trend and seasonality',\n    id: 'fplottrendseason-understanding-trend-and-seasonality',\n    children: []\n  }, {\n    value: 'bestAdstock: Adstock carryover and diminishing returns effects',\n    id: 'bestadstock-adstock-carryover-and-diminishing-returns-effects',\n    children: []\n  }, {\n    value: 'f.plotBestDecomp: Understanding the effect of baseline, media variables trend and seasonality along time',\n    id: 'fplotbestdecomp-understanding-the-effect-of-baseline-media-variables-trend-and-seasonality-along-time',\n    children: []\n  }, {\n    value: 'f.plotMAPEConverge: Understanding MAPE evolution per Random Search iteration and minutes spent',\n    id: 'fplotmapeconverge-understanding-mape-evolution-per-random-search-iteration-and-minutes-spent',\n    children: []\n  }, {\n    value: 'f.plotBestModDiagnostic: plot best model diagnostics: residual vs fitted, QQ plot and residual vs. actual',\n    id: 'fplotbestmoddiagnostic-plot-best-model-diagnostics-residual-vs-fitted-qq-plot-and-residual-vs-actual',\n    children: []\n  }]\n}];\n\nconst layoutProps = {\n  rightToc\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h2 {...{\n      \"id\": \"load-data--scripts\"\n    }}>{`Load data & scripts`}</h2>\n    <p>{`The first step is to load data and scripts, you can start with our simulated data file (de_simulated_data.csv) if you want to practice at the beginning.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`script_path <- str_sub(rstudioapi::getActiveDocumentContext()$path, start = 1, end = max(unlist(str_locate_all(rstudioapi::getActiveDocumentContext()$path, \"/\"))))\ndt_input <- fread(paste0(script_path,'de_simulated_data.csv'))\nholidays <- fread(paste0(script_path,'generated_holidays.csv'))\n`}</code></pre>\n    <p>{`Our script has been designed to pull files automatically from the folder where the fb_nextgen_mmm.exec.R script resides. If you would like to use a new data input file instead of our simulated data you will need to save it in the same folder and replace dt_input.csv file as in the example below:\nBefore\ndt_input <- fread(paste0(script_path,'de_simulated_data.csv'))\nAfter\ndt_input <- fread(paste0(script_path,'your_input_data_file.csv'))`}</p>\n    <h2 {...{\n      \"id\": \"set-model-input-variables\"\n    }}>{`Set model input variables`}</h2>\n    <p>{`Once you have defined the input files to work with and loaded to the source all the functions needed to run the code. You will need to define and set the input variables.`}</p>\n    <h3 {...{\n      \"id\": \"set_country\"\n    }}>{`set_country`}</h3>\n    <p>{`The first variable to declare is the country. We recommend using only one country especially if you are planning to leverage prophet for trend and seasonality which automatically pulls holidays for the country you have selected and simplifies the process.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_country <- \"DE\" # only one country allowed. Used in prophet holidays\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"set_datevarname\"\n    }}>{`set_dateVarName`}</h3>\n    <p>{`For date variables you must have in mind that the DATE column in your dataset has to be in  \"yyyy-mm-dd \" format. ie. \"2020-01-01\"`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_dateVarName <- c(\"DATE\") # date must be format \"2020-01-01\"\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"set_depvarname-and-set_depvartype\"\n    }}>{`set_depVarName and set_depVarType`}</h3>\n    <p>{`Setting the dependent variable is basically the outcome you are trying to measure. We only accept one dependent variable under set_depVarName. This variable can take the form of revenue (Sales or profit in monetary values) or conversion (Number of transactions, units sold) which you will indicate when defining the set_depVarType variable.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_depVarName <- c(\"revenue\") # there should be only one dependent variable\nset_depVarType <- \"revenue\" # \"revenue\" or \"conversion\" are allowed\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"set-prophet-variables\"\n    }}>{`Set Prophet variables`}</h3>\n    <h4 {...{\n      \"id\": \"activate_prophet\"\n    }}>{`activate_prophet`}</h4>\n    <p>{`First you will need to indicate the model if you would like to turn on or off the Prophet feature in the code to be used for seasonality, trend and holidays. T (True) means it is activated and F (False) deactivated.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`activate_prophet <- T\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"set_prophet\"\n    }}>{`set_prophet`}</h4>\n    <p>{`The next step is to select which of the provided outcomes of Prophet you will use in the model. It is recommended to at least keep trend and holidays. Please have in mind that \"trend\",\"season\", \"weekday\", \"holiday\" are provided and case-sensitive.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_prophet <- c(\"trend\", \"season\", \"holiday\")\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"set_prophetvarsign\"\n    }}>{`set_prophetVarSign`}</h4>\n    <p>{`You may define the variable sign control for prophet variables to be \"default\", \"positive\", or \"negative\". If you are expecting coefficients for prophet variables such as \"trend\", \"season\", \"holiday\" to be default (either positive or negative), positive or negative. We recommend using default. Please remember the object declared must be same length as set_prophets`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_prophetVarSign <- c(\"default\",\"default\", \"default\")\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"test-and-visualise-prophets-decomposition\"\n    }}>{`Test and visualise prophets decomposition`}</h4>\n    <p>{`You may drill-down into prophet results to understand better the outcomes provided by the tool by executing the following command.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`f.getProphet(dt_input)\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"set-baseline-variables\"\n    }}>{`Set Baseline variables`}</h3>\n    <p>{`The following step is to set the baseline variables which typically are things like competitors, pricing, promotions, temperature, unemployment rate and any other variable that is not media exposure but has a strong relationship with sales outcomes. You will need to indicate the model if you would like to turn on or off baseline variables in the code. T (True) means it is activated and F (False) deactivated.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`activate_baseline <- T\n`}</code></pre>\n    <p>{`You may then define the different baseline variables you would like to consider.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_baseVarName <- c(\"promotions\", \"price changes\", \"competitors sales\")\n`}</code></pre>\n    <p>{`You may apply sign control for baseline variables to be \"default\", \"positive\", or \"negative\". If you are expecting coefficients for baseline variables such as \"promotions\", \"price changes\", \"competitors sales\" to be default (either positive or negative), positive or negative depending on its expected relationship with the dependent variable. For example, rainy weather may have a positive or negative impact in sales depending on the business. Please remember the object declared must be same length as set_baseVarNames`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_baseVarSign <- c(\"negative\") # c(\"default\", \"positive\", and \"negative\")\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"set_mediavarname-and-set_mediaspendname\"\n    }}>{`set_mediaVarName and set_mediaSpendName`}</h3>\n    <p>{`There is one key restriction to have in mind here, you must have spend variables declared for every media channel you would like to measure. So they have to be in the same order and same length as set_mediaVarName variables.`}</p>\n    <p>{`Correct`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_mediaVarName <- c(\"tv_S\"    ,\"ooh_S\",   \"print_S\"   ,\"facebook_I\"   ,\"search_clicks_P\")\n\nset_mediaSpendName <- c(\"tv_S\"  ,\"ooh_S\",   \"print_S\"   ,\"facebook_S\"   ,\"search_S\")\n`}</code></pre>\n    <p>{`Incorrect`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_mediaVarName <- c(\"tv_S\"    ,\"ooh_S\",   \"print_S\"   ,\"facebook_I\"   ,\"search_clicks_P\")\n\nset_mediaSpendName <- c(\"tv_S\"  ,\"ooh_S\",   \"print_S\")\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"set_mediavarsign\"\n    }}>{`set_mediaVarSign`}</h4>\n    <p>{`You may apply sign control for media variables to be \"default\", \"positive\", or \"negative\". If you are expecting coefficients for baseline variables such as \"tv\", \"print\", \"facebook\" to be default (either positive or negative), positive or negative depending on its expected relationship with the dependent variable. We recommend using positive for all. Please remember the object declared must be same length as set_mediaVarNames`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_mediaVarSign <- c(\"positive\", \"positive\", \"positive\", \"positive\", \"positive\")\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"set-factor-variables\"\n    }}>{`Set factor variables`}</h3>\n    <p>{`If any variable above should be factor please include it in this section of the code, otherwise leave it empty as by default c()`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_factorVarName <- c()\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"set-global-model-parameters\"\n    }}>{`Set global model parameters`}</h2>\n    <p>{`In this section you will have to define parameters values and bounds for the model to start working:`}</p>\n    <ol>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`The `}<strong parentName=\"p\">{`number of cores`}</strong>{` in your computer to be used for `}<strong parentName=\"p\">{`parallel computing`}</strong></p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`The `}<strong parentName=\"p\">{`data training size`}</strong>{` (set_modTrainSize) which will indicate the percentage of data to be used to train the model, therefore, the percentage left (1- training size) to validate the model.`}</p>\n        <ol parentName=\"li\">\n          <li parentName=\"ol\">{`The function f.plotTrainSize helps you select the best split. Set the function to f.plotTrainSize(TRUE) to plot the Bhattacharyya coefficient, an indicator for the similarity of two distributions, for the training size 50-90%. The higher the Bhatta coefficient, the more similar the train and test data splits and thus the better the potential model fit in the end.`}</li>\n        </ol>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`The adstocking method which can be `}<a parentName=\"p\" {...{\n            \"href\": \"https://en.wikipedia.org/wiki/Geometric_distribution\"\n          }}>{`Geometric`}</a>{` or `}<a parentName=\"p\" {...{\n            \"href\": \"https://en.wikipedia.org/wiki/Weibull_distribution\"\n          }}>{`Weibull`}</a>{` distributions.`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`The `}<strong parentName=\"p\">{`number of iterations`}</strong>{` (set_iter) your model will have to find optimum values for coefficients.`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`The `}<strong parentName=\"p\">{`hyperparameters bounds`}</strong>{` which we recommend to leave as default but can be changed according to learnings from model iterations and analysts past experience.`}</p>\n        <ol parentName=\"li\">\n          <li parentName=\"ol\">\n            <p parentName=\"li\"><strong parentName=\"p\">{`The definition of each hyperparameter:`}</strong></p>\n            <ol parentName=\"li\">\n              <li parentName=\"ol\"><strong parentName=\"li\">{`Thetas`}</strong>{`: Geometric function decay rate`}</li>\n              <li parentName=\"ol\"><strong parentName=\"li\">{`Shapes`}</strong>{`: Weibull parameter that controls the decay shape between exponential and s-shape`}</li>\n              <li parentName=\"ol\"><strong parentName=\"li\">{`Scales`}</strong>{`: Weibull parameter that controls the position of inflection point`}</li>\n              <li parentName=\"ol\"><strong parentName=\"li\">{`Alphas`}</strong>{`: Hill function (Diminishing returns) parameter that controls the shape between exponential and s-shape`}</li>\n              <li parentName=\"ol\"><strong parentName=\"li\">{`Gammas`}</strong>{`: Hill function (Diminishing returns) parameter that controls the scale of transformation`}</li>\n              <li parentName=\"ol\"><strong parentName=\"li\">{`Lambdas`}</strong>{`: Regularization penalty parameter for ridge regression`}</li>\n            </ol>\n          </li>\n          <li parentName=\"ol\">\n            <p parentName=\"li\"><strong parentName=\"p\">{`Understanding how adstock affects media transformation:`}</strong></p>\n            <ol parentName=\"li\">\n              <li parentName=\"ol\">{`In order to make more informed decisions to define hyperparameter values, its very helpful to know which hyperparameter is doing what during the media transformation. The plot function f.plotAdstockCurves helps you understand exactly that.`}</li>\n              <li parentName=\"ol\">{`Below is the geometric adstock that is a one parameter (theta) function. Assume the time unit is week, then we can see that when theta=0.9, meaning 90% of the media effect this week carries over to the next week, the halflife enters after 8 weeks (halflife value in legend). In other words, it takes 8 weeks until the media effect decays to half when theta=0.9. This should help you having a more tangible feeling about if the theta value for this certain channel makes normal sense.`}</li>\n            </ol>\n          </li>\n        </ol>\n      </li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"adstockintro chart\" src={useBaseUrl('/img/adstockintro.png')} />\n`}</code></pre>\n    <p>{`Similar to above, this plot visualises the two-parameter (scale & shape) Weibull function. The upper plot shows changes in scale while keeping shape constant. We can observe that the larger the scale, the later the inflexion point. When scale=0.5 and shape = 2, it takes 18 weeks until the media effect decays to half (see legend). The lower plot shows changes in shape while keeping scale constant. When shape is smaller, the curve  rather takes on the L-shape. When shape is larger, the curve rather takes on S-shape.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"adstockintro2 chart\" src={useBaseUrl('/img/adstockintro2.png')} />\n`}</code></pre>\n    <p>{`In order to start setting model parameters we recommend to start with the Geometric function.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`## set model core features\nadstock <- \"geometric\"\n`}</code></pre>\n    <p>{`This function is simpler and therefore easier to understand compared to the weibull function.  You may start by focusing on Thetas bounds, which controls for the decay rate any channel could take. If you are not sure about decay rates for your channels, we suggest you start with a range: thetas = c(0, 0.5). This means that in a week by week dataset, we would be expecting a maximum carryover effect of 50% of previous weeks values to be extended and added to the following weeks values for the dependent variable (Sales, impressions, etc.)`}</p>\n    <p>{`Once you run one of the iterations you may notice theta's values and if certain optimums have been found by looking into variables including 'thetas' on their names and identifying the number of times an optimum was found (epoch.optim).`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"coderesults1 chart\" src={useBaseUrl('/img/coderesults1.png')} />\n`}</code></pre>\n    <p>{`In the example above, you will see that Facebook and TV thetas are still missing an optimum given that optim.found column has still TRUE values on it, for this we suggest to increase epoch number to Inf (Infinity) until an optimum is found.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`model_output <- f.mmmRobyn(set_hyperBoundGlobal\n                          ,set_iter = set_iter\n                          ,set_cores = set_cores\n                          ,epochN = Inf # set to Inf to auto-optimise until no optimum found\n                          ,optim.sensitivity = 0 # must be from -1 to 1. Higher sensitivity means finding optimum easier\n                          ,temp.csv.path = '/Users/leonelsentana/Documents/mmm.tempout.csv' # output optimisation result for each epoch. Use getwd() to find path\n                          )\n`}</code></pre>\n    <p>{`Below an example reaching optimum in 33 epochs:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"coderesults2 chart\" src={useBaseUrl('/img/coderesults2.png')} />\n`}</code></pre>\n    <p>{`You may note all parameters state FALSE which means there are not any more optimums to find. This indicates that the values found are optimal, and that if wanted, you could use some of these mode values to fix hyperparameter values in the #### tune channel hyperparameters bounds section.`}</p>\n    <h2 {...{\n      \"id\": \"tune-channel-hyperparameters-bounds\"\n    }}>{`Tune channel hyperparameters bounds`}</h2>\n    <p>{`For that you will need to set the following command to TRUE:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`activate_hyperBoundLocalTuning <- T\n`}</code></pre>\n    <p>{`This command will enable you to define the bounds each medias parameter should have manually. Please uncomment the following section of the code and define the values. Each bound can be either a range (e.g c(0.1,0.9)) or a fixed value:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{` set_hyperBoundLocal <- list(\n   facebook_I_alphas = c(0.8356271, 0.8371774)\n   ,facebook_I_gammas = c(0.8991811, 0.9012183)\n   ,facebook_I_thetas = c(0.8700282)\n   ,ooh_S_alphas = c(0.8348503)\n   ,ooh_S_gammas = c(0.3565417)\n   ,ooh_S_thetas = c(0.3815053)\n   ,print_S_alphas = c(0.6490568)\n   ,print_S_gammas = c(0.1165910, 0.1171953)\n   ,print_S_thetas = c(0.7617390)\n   ,tv_S_alphas = c(2.4880460)\n   ,tv_S_gammas = c(0.8867124)\n   ,tv_S_thetas = c(0.1477954, 0.1478531)\n   ,search_clicks_P_alphas = c(0.1360708)\n   ,search_clicks_P_gammas = c(0.4177802)\n   ,search_clicks_P_thetas = c(0.5784685)\n )\n`}</code></pre>\n    <p>{`The hyperparameters tuning section is especially handy when we know there is an expected behavior behind parameters e.g. adstocking for TV decay rate taking only a value within a range. In this case, we would recommend you to guide the model towards a solution that is both optimal and meets your needs based on experience from previous analyses.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"coderesults2 chart\" src={useBaseUrl('/img/coderesults2.png')} />\n`}</code></pre>\n    <p>{`If we consider our previous example, it could be the case where you may want to tune Theta decay rates to control for the adstocking decay pacing of TV to `}<strong parentName=\"p\">{`tv_S_thetas = c(0.25, 0.35)`}</strong>{`. If we also fix other values where optimums have been reached, we would reach something like the example below with fix values and ranges based on previous iterations and past experience:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`#Please uncomment set_hyperBoundLocal list completely and use scales and shapes only if you\n#have selected adstock <- \"weibull\". If you selected adstock <- \"geometric\" as by default, then simply #use alphas, gammas and thetas for each channel.\n\n set_hyperBoundLocal <- list(\n   facebook_I_alphas = c(0.8356271, 0.8371774)\n   ,facebook_I_gammas = c(0.8991811, 0.9012183)\n   ,facebook_I_thetas = 0.8700282\n   ,ooh_S_alphas = 0.8348503\n   ,ooh_S_gammas = 0.3565417\n   ,ooh_S_thetas = 0.3815053\n   ,print_S_alphas = 0.6490568\n   ,print_S_gammas = c(0.1165910, 0.1171953)\n   ,print_S_thetas = 0.7617390\n   ,search_clicks_P_alphas = 0.1360708\n   ,search_clicks_P_gammas = 0.4177802\n   ,search_clicks_P_thetas = 0.5784685\n   ,tv_S_alphas = 2.4880460\n   ,tv_S_gammas = 0.8867124\n   ,tv_S_thetas = c(0.25, 0.35)\n )\n`}</code></pre>\n    <p>{`If we apply the above bounds to our media related variables, you may see that results now reach an optimum much faster, after only 2 epochs instead of 33. You may also observe that the new bounds for `}<strong parentName=\"p\">{`tv_S_thetas = c(0.25, 0.35)`}</strong>{` have been applied, therefore the new optimum found is 0.2706085 instead of the 0.1478256 from the previous example.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"coderesults3 chart\" src={useBaseUrl('/img/coderesults3.png')} />\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"plotting-and-understanding-results\"\n    }}>{`Plotting and understanding results`}</h2>\n    <p>{`The first thing you will have to do, is to set every plot you would like to be drawn to TRUE (T):`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`#### Plot section\n\n## insert TRUE into plot functions to plot\nf.plotSpendModel(F)\nf.plotHyperSamp(F, channelPlot = set_mediaVarName) # plot latin hypercube hyperparameter sampling balance. Max. 3 channels per plot\nf.plotTrendSeason(F) # plot prophet trend, season and holiday decomposition\nbestAdstock <- f.plotMediaTransform(T, channelPlot = set_mediaVarName) # plot best model media transformation with 3 plots: adstock decay rate, adstock effect & response curve. Max. 3 channels per plot\nf.plotBestDecomp(F) # plot best model decomposition with 3 plots: sales decomp, actual vs fitted over time, & sales decomp area plot\nf.plotMAPEConverge(F) # plot RS MAPE convergence, only for random search\nf.plotBestModDiagnostic(F) # plot best model diagnostics: residual vs fitted, QQ plot and residual vs. actual\nf.plotChannelROI(F)\nf.plotHypConverge(F, channelPlot = set_mediaVarName) # plot hyperparameter vs MAPE convergence. Max. 3 channels per plot\nboundOptim <- f.plotHyperBoundOptim(F, channelPlot = set_mediaVarName, model_output, kurt.tuner = optim.sensitivity)  # improved hyperparameter plot to better visualise trends in each hyperparameter\n`}</code></pre>\n    <p>{`After that, you may execute each plot separately and analyze it.`}</p>\n    <h3 {...{\n      \"id\": \"fplotspendmodel-plotting-the-spend-reach-fitting-with-michaelis-menten-model\"\n    }}>{`f.plotSpendModel: Plotting the spend-reach fitting with Michaelis-Menten model`}</h3>\n    <p>{`The plot below illustrates how to better translate the relationship between spend and reach so that you can apply it to performance ROI (Revenue/spend) calculations. It is possible to choose reach variables (GRP, impressions, actual reach, etc.) in the model. Understanding that relationship can help with the translation of reach to spend and vice versa.\nLM (Linear Model) and NLS (Non-linear least squares) comparison shows why it is better to use a non-linear model, which is the technique applied in the code. The linear model is actually as primitive as just using average to scale, because in our case the intercept is omitted given that we assume no spend involves no reach. Whereas NLS are more flexible and should adapt better to the underlying correlation patterns between both variables.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"plotSpendModel chart\" src={useBaseUrl('/img/plotSpendModel.png')} />\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"fplothypersamp-checking-latin-hypercube-sampling-distribution\"\n    }}>{`f.plotHyperSamp: checking latin hypercube sampling distribution`}</h3>\n    <p>{`The overall idea of these charts is to validate the `}<strong parentName=\"p\">{`Latin hypercube sampling (LHS)`}</strong>{`, which is a statistical method for generating a near-random sample of parameter values from the multidimensional distribution of hyperparameters. It consists of two main charts:`}</p>\n    <ul>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Latin Hypercube Sampling distribution:`}</strong>{` The key aspect is to concentrate on the randomness of the points on this chart. If all dots seem to cover evenly the space as in the example below, then sampling is ok. However, beware of high concentrations of dots or clear areas without any dots which may mean you will have to increase the sampling to have a better representation of the hyperspace.`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Latin Hypercube Sampling distribution transformed:`}</strong>{` This is a half violin chart that represents the distribution of each media parameter values. It helps you understand the actual range of values that each parameter is taking in order to represent uniformly the hyperparameter space. It will also depend on the set_hyperBoundGlobal variable and its bound definitions.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"plotHyperSamp chart\" src={useBaseUrl('/img/plotHyperSamp.png')} />\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"fplottrendseason-understanding-trend-and-seasonality\"\n    }}>{`f.plotTrendSeason: Understanding trend and seasonality`}</h3>\n    <p>{`This plot describes the trend, holidays and seasonality along the analyzed period.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`The `}<strong parentName=\"li\">{`trend`}</strong>{` is the component of a time series that represents low frequency variations in time. It reflects the underlying tendency behind the dependent variable which can reflect growth, stability or shrinkage depending on the time unit analyzed.`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Holidays`}</strong>{` are basically days defined by governments where people commemorate events which can affect consumption behaviors. Some holidays may have more impact than others, therefore the different magnitudes on the chart.`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Seasonality`}</strong>{` is a characteristic of a time series in which the time series experiences regular and predictable changes that recur every calendar year. Any predictable fluctuation or pattern that recurs or repeats over a one-year period is said to be seasonal. Below we have the yearly seasonality as an example, which shows higher demand between October and December, and lower demand between April and July.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"plotTrendSeason chart\" src={useBaseUrl('/img/plotTrendSeason.png')} />\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"bestadstock-adstock-carryover-and-diminishing-returns-effects\"\n    }}>{`bestAdstock: Adstock carryover and diminishing returns effects`}</h3>\n    <p>{`This plot represents the relationship between spend or ROI, and the response variable (Sales, conversions, etc.).\nOn the first line of charts you will find:\nThe response curve which can be S or C like, its scale of growth and diminishing returns pace.\nThe profit curve which illustrates the difference between the Y and X axes (Response-profit). The higher this curve is on the Y axis, the closer to a max profit point you will get.\nThe second line of charts displays the relationship between ROI and spend, the higher the curve on the Y axis, the greater the response obtained. Maximum and Average ROI are drawn for an easier read.`}</p>\n    <p>{`Note: This plot admits only 3 channels at a time. Please select the 3 channels you would like to analyze as in the example below where first we look at channel names, and second, we indicate which names within set_mediaVarName object to plot c(1,2,5) :`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`set_mediaVarName\nbestAdstock <- f.plotMediaTransform(T, channelPlot = set_mediaVarName[c(1,2,5)])\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"bestAdstock chart\" src={useBaseUrl('/img/bestAdstock.png')} />\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"fplotbestdecomp-understanding-the-effect-of-baseline-media-variables-trend-and-seasonality-along-time\"\n    }}>{`f.plotBestDecomp: Understanding the effect of baseline, media variables trend and seasonality along time`}</h3>\n    <p>{`The aim of this chart is to display the breakdown of the response variable through time and the relationship with each of its regressing components. As with all marketing mix models, both media and non-media related explanatory factors are displayed, including baseline effects such as price and promotions, as well as, trend , seasonality and holidays. In order to be able to make a proper description and forecast of performance, we must know to what extent each component is present in the data.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"plotBestDecomp chart\" src={useBaseUrl('/img/plotBestDecomp.png')} />\n`}</code></pre>\n    <p>{`The chart below illustrates the contribution of each regressor variable to the overall response (Sales in this case) You may find for example that Facebook impressions had a 7.6% contribution to overall sales which represent in total $28.8 million.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"bestDecomp2 chart\" src={useBaseUrl('/img/bestDecomp2.png')} />\n`}</code></pre>\n    <p>{`The next chart shows the difference between real and predicted values. The closer the lines for y and y_pred, the better. You may also find RSQ and MAPE metrics. RSQ or R-squared (R2) is a statistical measure that represents the proportion of the variance for a dependent variable that is explained by an independent variable or variables in a regression model. In general terms, the closer to one, the better.  Whereas, the mean absolute percentage error (MAPE) is the mean or average of the absolute percentage errors of forecasts. Error is defined as actual or observed value minus the forecasted value. As a general rule, the closer to zero the better.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"bestDecomp3 chart\" src={useBaseUrl('/img/bestDecomp3.png')} />\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"fplotmapeconverge-understanding-mape-evolution-per-random-search-iteration-and-minutes-spent\"\n    }}>{`f.plotMAPEConverge: Understanding MAPE evolution per Random Search iteration and minutes spent`}</h3>\n    <p>{`The chart below displays the evolution of the mean absolute percentage error (MAPE) with every minute spent on computing. This chart will help you understand how many random search iterations to include in the model under `}<strong parentName=\"p\">{`set_iter`}</strong>{` variable. If you increase set_iter from 100 to 10000, you will reach a point where MAPE will not decrease in time. Therefore, finding the optimum may be between 100 and 10000 may be your next step until you find the balance between computing time and MAPE reduction.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"plotMAPEConverge chart\" src={useBaseUrl('/img/plotMAPEConverge.png')} />\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"fplotbestmoddiagnostic-plot-best-model-diagnostics-residual-vs-fitted-qq-plot-and-residual-vs-actual\"\n    }}>{`f.plotBestModDiagnostic: plot best model diagnostics: residual vs fitted, QQ plot and residual vs. actual`}</h3>\n    <p>{`Across these plots we analyze residuals, which are the difference between the observed value of the dependent variable (y) and the predicted value ().`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\"><strong parentName=\"p\">{`Fitted vs. Residual:`}</strong>{` When conducting a residual analysis, a \"residuals versus fitted plot\" is the most frequently created plot. It is a scatter plot of residuals on the y axis and fitted values (estimated responses) on the x axis. The plot is used to detect non-linearity, unequal error variances, and outliers. The more random the pattern for the dots distribution in this plot and the more horizontal the smooth line, the better, as it would mean linearity, independent error variances and absence of outliers.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\"><strong parentName=\"p\">{`QQ Plot:`}</strong>{` The quantile-quantile (q-q) plot is a graphical technique to determine if two data sets come from populations with a common distribution. A q-q plot is a plot of the quantiles of the first data set against the quantiles of the second data set in this case observed Y and Y_pred. A 45-degree reference line is also plotted. The closer the dots to the 45 degrees line, the better.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\"><strong parentName=\"p\">{`Observed vs. Residual:`}</strong>{` Compared to the Fitted vs. Residual plot, this plot shows more correlation between observed/true response vs. residuals when the model R2 is lower. Normally, a certain degree of correlation here means either the data is just noisy or theres still missing patterns within the error. In the context of MMM, we would recommend to assume the latter one and look for potential additional predictors to also capture these patterns.\nWhen conducting a residual analysis, a \"residuals versus observed plot\" is commonly used as a complement of residual vs. fitted plots. It is a scatter plot of residuals on the y axis and observed values (Actual responses) on the x axis. The plot is used to detect non-linearity, unequal error variances, and outliers. The more uniform the dots distribution in this plot and the more horizontal the smooth line, the better as it would mean independent error variances and absence of outliers. The contrast between fitted and observed vs. residual charts helps to understand if there are common relationships between both and residuals.`}</p>\n      </li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`<img alt=\"f.plotBestModDiagnostic chart\" src={useBaseUrl('/img/f.plotBestModDiagnostic.png')} />\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\n  "]}]}