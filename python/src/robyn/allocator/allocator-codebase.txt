================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-30T17:18:07.405Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
entities/
  allocation_config.py
  allocation_constraints.py
  allocation_results.py
  enums.py
allocation_optimizer.py
budget_allocator.py
media_response.py
response_calculator.py

================================================================
Repository Files
================================================================

================
File: entities/allocation_config.py
================
from dataclasses import dataclass
from typing import Optional, Union, List
from datetime import datetime

from .enums import OptimizationScenario, ConstrMode
from .allocation_constraints import AllocationConstraints


@dataclass
class AllocationConfig:
    """Configuration for the allocation optimization process."""

    scenario: OptimizationScenario
    total_budget: Optional[float] = None
    target_value: Optional[float] = None
    date_range: Union[str, List[str], datetime] = "all"
    constraints: AllocationConstraints = None
    maxeval: int = 100000
    optim_algo: str = "SLSQP_AUGLAG"  # Sequential Least-Squares Quadratic Programming
    constr_mode: ConstrMode = ConstrMode.EQUALITY
    plots: bool = True
    export: bool = True
    quiet: bool = False


@dataclass
class DateRange:
    """Date range information for allocation calculations."""

    start_date: datetime
    end_date: datetime
    start_index: int
    end_index: int
    n_periods: int
    interval_type: str

================
File: entities/allocation_constraints.py
================
from dataclasses import dataclass
from typing import Dict, List
import numpy as np


@dataclass
class AllocationConstraints:
    """Constraints for channel allocations."""

    channel_constr_low: Dict[str, float]
    channel_constr_up: Dict[str, float]
    channel_constr_multiplier: float = 3.0

    def __post_init__(self):
        """Validate constraints after initialization."""
        self._validate_constraints()

    def _validate_constraints(self):
        """Ensure constraints are valid."""
        if any(v < 0.01 for v in self.channel_constr_low.values()):
            raise ValueError("Lower bounds must be >= 0.01")

        if any(v > 5 for v in self.channel_constr_up.values()):
            raise ValueError("Upper bounds should be < 5")

    def get_bounds(self, initial_spend: Dict[str, float]) -> List[tuple]:
        """Get bounds for optimization."""
        bounds = []
        for channel in initial_spend.keys():
            lower = initial_spend[channel] * self.channel_constr_low[channel]
            upper = initial_spend[channel] * self.channel_constr_up[channel]
            bounds.append((lower, upper))
        return bounds

================
File: entities/allocation_results.py
================
from dataclasses import dataclass, field
from typing import Dict, Any
import pandas as pd
import numpy as np


@dataclass
class ChannelAllocation:
    """Allocation results for a single channel."""

    channel: str
    current_spend: float
    optimal_spend: float
    spend_change_pct: float
    response: float
    roi: float
    contribution_pct: float


@dataclass
class AllocationResult:
    """Complete results from budget allocation optimization."""

    optimal_allocations: pd.DataFrame
    predicted_responses: pd.DataFrame
    response_curves: pd.DataFrame
    metrics: Dict[str, float]
    summary: str = field(init=False)

    def __post_init__(self):
        """Generate summary after initialization."""
        self.summary = self._generate_summary()

    def _generate_summary(self) -> str:
        """Generate a text summary of allocation results."""
        # Handle both max_response and target_efficiency scenarios
        budget_value = self.metrics.get("total_budget") or self.metrics.get("total_spend", 0)

        return f"""
        Optimization Results Summary:
        Total Spend: ${budget_value:,.2f}
        Expected Response Lift: {self.metrics['response_lift']*100:.1f}%
        Channels Optimized: {len(self.optimal_allocations)}
        {self._get_efficiency_summary()}
        """

    def _get_efficiency_summary(self) -> str:
        """Generate efficiency metrics summary if available."""
        if "achieved_efficiency" in self.metrics and "target_efficiency" in self.metrics:
            return f"""
        Target Efficiency: {self.metrics['target_efficiency']:.2f}
        Achieved Efficiency: {self.metrics['achieved_efficiency']:.2f}
        """
        return ""

================
File: entities/enums.py
================
from enum import Enum, auto


class OptimizationScenario(str, Enum):
    """Available optimization scenarios for budget allocation."""

    MAX_RESPONSE = "max_response"  # Maximize response while keeping budget constant
    TARGET_EFFICIENCY = "target_efficiency"  # Optimize spend based on target ROAS/CPA


class ConstrMode(str, Enum):
    """Constraint modes for optimization."""

    EQUALITY = "eq"
    INEQUALITY = "ineq"


class UseCase(str, Enum):
    """Defines different use cases for allocation."""

    ALL_HISTORICAL_VEC = "all_historical_vec"
    SELECTED_HISTORICAL_VEC = "selected_historical_vec"
    TOTAL_METRIC_DEFAULT_RANGE = "total_metric_default_range"
    TOTAL_METRIC_SELECTED_RANGE = "total_metric_selected_range"
    UNIT_METRIC_DEFAULT_LAST_N = "unit_metric_default_last_n"
    UNIT_METRIC_SELECTED_DATES = "unit_metric_selected_dates"

================
File: allocation_optimizer.py
================
from typing import Callable, List, Tuple, Dict
import numpy as np
from scipy.optimize import minimize
from robyn.allocator.entities.enums import ConstrMode


class AllocationOptimizer:
    """Handles numerical optimization for budget allocation."""

    def __init__(self):
        """Initialize optimizer."""
        self.supported_methods = {
            "SLSQP_AUGLAG": "SLSQP",  # Map Robyn method names to scipy method names
            "MMA_AUGLAG": "SLSQP",  # For now, map both to SLSQP as it's most similar
        }

    def optimize(
        self,
        objective_func: Callable,
        bounds: List[Tuple[float, float]],
        constraints: List[Dict],
        initial_guess: np.ndarray,
        method: str = "SLSQP_AUGLAG",
        maxeval: int = 100000,
        constr_mode: ConstrMode = ConstrMode.EQUALITY,
    ) -> Dict:
        """
        Run optimization with given objective and constraints.

        Args:
            objective_func: Function to minimize
            bounds: List of (lower, upper) bounds for each variable
            constraints: List of constraint dictionaries
            initial_guess: Initial values for optimization
            method: Optimization method (SLSQP_AUGLAG or MMA_AUGLAG)
            maxeval: Maximum number of function evaluations
            constr_mode: Constraint mode (equality or inequality)

        Returns:
            Dictionary containing optimization results
        """
        # Convert method name to scipy solver name
        if method not in self.supported_methods:
            raise ValueError(
                f"Unsupported optimization method: {method}. "
                f"Supported methods are: {list(self.supported_methods.keys())}"
            )

        scipy_method = self.supported_methods[method]

        # Setup optimization options
        options = {"maxiter": maxeval, "ftol": 1e-10, "disp": False}

        # Process constraints
        processed_constraints = []
        for c in constraints:
            constraint_type = c.get("type", "eq")
            if constraint_type not in ["eq", "ineq"]:
                raise ValueError(f"Invalid constraint type: {constraint_type}")

            processed_constraints.append({"type": constraint_type, "fun": c["fun"], "jac": c.get("jac")})

        try:
            # Run optimization
            result = minimize(
                fun=objective_func,
                x0=initial_guess,
                method=scipy_method,
                bounds=bounds,
                constraints=processed_constraints,
                options=options,
            )

            if not result.success:
                print(f"Warning: Optimization may not have converged. Message: {result.message}")

            # Return results in a consistent format
            return {
                "x": result.x,
                "fun": result.fun,
                "success": result.success,
                "message": result.message,
                "nfev": result.nfev,
                "nit": result.nit if hasattr(result, "nit") else None,
            }

        except Exception as e:
            raise ValueError(f"Optimization failed: {str(e)}")

================
File: budget_allocator.py
================
from typing import List, Dict, Optional, Tuple
import numpy as np
import pandas as pd
from datetime import datetime

from robyn.data.entities.mmmdata import MMMData
from robyn.modeling.entities.modeloutputs import ModelOutputs
from robyn.data.entities.hyperparameters import Hyperparameters
from robyn.allocator.media_response import MediaResponseParameters, MediaResponseParamsCalculator

from robyn.allocator.entities.allocation_config import AllocationConfig, DateRange
from robyn.allocator.entities.allocation_results import AllocationResult
from robyn.allocator.entities.enums import OptimizationScenario
from robyn.allocator.allocation_optimizer import AllocationOptimizer
from robyn.allocator.response_calculator import ResponseCurveCalculator

from robyn.modeling.pareto.pareto_optimizer import ParetoResult
from typing import List, Dict, Optional, Union, Tuple, Any
import numpy as np
import pandas as pd
from datetime import datetime, timedelta

from robyn.data.entities.mmmdata import MMMData
from robyn.modeling.entities.modeloutputs import ModelOutputs
from robyn.modeling.pareto.pareto_optimizer import ParetoResult
from robyn.allocator.entities.allocation_config import AllocationConfig, DateRange
from robyn.allocator.entities.enums import OptimizationScenario, ConstrMode, UseCase
from robyn.allocator.entities.allocation_results import AllocationResult
from robyn.allocator.entities.allocation_constraints import AllocationConstraints
from robyn.modeling.feature_engineering import FeaturizedMMMData


class BudgetAllocator:
    """Main class for optimizing marketing budget allocations."""

    def __init__(
        self,
        mmm_data: MMMData,
        featurized_mmm_data: FeaturizedMMMData,
        model_outputs: ModelOutputs,
        pareto_result: ParetoResult,
        select_model: str,
    ):
        """Initialize the BudgetAllocator."""
        self.mmm_data = mmm_data
        self.featurized_mmm_data = featurized_mmm_data
        self.model_outputs = model_outputs
        self.pareto_result = pareto_result
        self.select_model = select_model

        # Validate date data
        self._validate_date_data()

        # Initialize calculators
        self.media_params_calculator = MediaResponseParamsCalculator(
            mmm_data=mmm_data, pareto_result=pareto_result, select_model=select_model
        )
        self.response_calculator = ResponseCurveCalculator()
        self.optimizer = AllocationOptimizer()

        # Calculate media response parameters
        self.media_params = self.media_params_calculator.calculate_parameters()

    def _process_date_range(self, date_range: Union[str, List[str], datetime]) -> DateRange:
        """Process and validate date range for allocation calculations."""
        # Get correct date column name
        date_col = self._get_date_column_name()

        # Get dates from data
        raw_dates = self.mmm_data.data[date_col]
        if not pd.api.types.is_datetime64_any_dtype(raw_dates):
            dates = pd.to_datetime(raw_dates, format=None)
        else:
            dates = raw_dates

        # Process the date range
        try:
            if isinstance(date_range, str):
                if date_range == "all":
                    start_date = dates.min()
                    end_date = dates.max()
                elif date_range == "last":
                    end_date = dates.max()
                    start_date = end_date
                elif date_range.startswith("last_"):
                    n = int(date_range.split("_")[1])
                    if n > len(dates):
                        raise ValueError(f"Requested last_{n} dates but only {len(dates)} dates available")
                    end_date = dates.max()
                    start_date = dates.iloc[-n]
                else:
                    start_date = end_date = pd.to_datetime(date_range)
            else:
                if isinstance(date_range, list):
                    start_date = pd.to_datetime(date_range[0])
                    end_date = pd.to_datetime(date_range[1])
                else:
                    start_date = end_date = pd.to_datetime(date_range)

            # Validate dates are within range
            if start_date < dates.min() or end_date > dates.max():
                raise ValueError(
                    f"Date range {start_date} to {end_date} outside available data range "
                    f"{dates.min()} to {dates.max()}"
                )

            # Get indices
            start_idx = dates[dates >= start_date].index[0]
            end_idx = dates[dates <= end_date].index[-1]
            n_periods = end_idx - start_idx + 1

            if n_periods < 1:
                raise ValueError(f"Invalid date range: {start_date} to {end_date}")

            return DateRange(
                start_date=start_date,
                end_date=end_date,
                start_index=start_idx,
                end_index=end_idx,
                n_periods=n_periods,
                interval_type=self.mmm_data.mmmdata_spec.interval_type,
            )

        except Exception as e:
            raise ValueError(f"Error processing date range {date_range}: {str(e)}")

    def _calculate_initial_metrics(
        self, date_range: DateRange, media_spend_sorted: np.ndarray, total_budget: Optional[float]
    ) -> Dict[str, Any]:
        """Calculate initial metrics for optimization."""
        # Use data directly from mmm_data
        dt_mod = self.mmm_data.data

        # Get historical spend data using proper date column
        hist_spend = dt_mod.loc[date_range.start_index : date_range.end_index, media_spend_sorted]
        # Calculate spend statistics
        hist_spend_total = hist_spend.sum()
        hist_spend_mean = hist_spend.mean()
        hist_spend_share = hist_spend_mean / hist_spend_mean.sum()

        # Calculate initial responses using media parameters
        init_responses = {}
        response_margins = {}

        for channel in media_spend_sorted:
            spend = hist_spend_mean[channel]
            params = self.media_params

            response = self.response_calculator.calculate_response(
                spend=spend,
                coef=params.coefficients[channel],
                alpha=params.alphas[channel],
                inflexion=params.inflexions[channel],
            )

            margin = self.response_calculator.calculate_gradient(
                spend=spend,
                coef=params.coefficients[channel],
                alpha=params.alphas[channel],
                inflexion=params.inflexions[channel],
            )

            init_responses[channel] = response
            response_margins[channel] = margin

        # Calculate totals
        init_spend_total = hist_spend_mean.sum()
        init_response_total = sum(init_responses.values())

        # Handle total budget
        if total_budget is not None:
            budget_unit = total_budget / date_range.n_periods
        else:
            budget_unit = init_spend_total

        return {
            "hist_spend_total": hist_spend_total,
            "hist_spend_mean": hist_spend_mean,
            "hist_spend_share": hist_spend_share,
            "init_responses": init_responses,
            "response_margins": response_margins,
            "init_spend_total": init_spend_total,
            "init_response_total": init_response_total,
            "budget_unit": budget_unit,
            "date_range": date_range,
        }

    def _optimize_max_response(self, initial_metrics: Dict[str, Any], config: AllocationConfig) -> AllocationResult:
        """Optimize for maximum response while respecting budget constraint.

        Args:
            initial_metrics: Dictionary of initial metrics
            config: Allocation configuration

        Returns:
            AllocationResult containing optimization results
        """
        # Set up optimization problem
        x0 = initial_metrics["hist_spend_mean"].values

        # Get bounds from constraints
        bounds = config.constraints.get_bounds(initial_metrics["hist_spend_mean"])

        # Define objective function for maximizing response
        def objective(x):
            total_response = 0
            for i, channel in enumerate(self.mmm_data.mmmdata_spec.paid_media_spends):
                response = self.response_calculator.calculate_response(
                    spend=x[i],
                    coef=self.media_params.coefficients[channel],
                    alpha=self.media_params.alphas[channel],
                    inflexion=self.media_params.inflexions[channel],
                )
                total_response += response
            return -total_response  # Negative because we're minimizing

        # Define budget constraint
        def budget_constraint(x):
            return np.sum(x) - initial_metrics["budget_unit"]

        constraints = [
            {"type": "eq" if config.constr_mode == ConstrMode.EQUALITY else "ineq", "fun": budget_constraint}
        ]

        # Run optimization
        try:
            result = self.optimizer.optimize(
                objective_func=objective,
                bounds=bounds,
                constraints=constraints,
                initial_guess=x0,
                method=config.optim_algo,
                maxeval=config.maxeval,
            )

            if not result["success"]:
                print(f"Warning: {result['message']}")

            # Get optimal allocations
            optimal_spend = result["x"]
            optimal_responses = {}

            for i, channel in enumerate(self.mmm_data.mmmdata_spec.paid_media_spends):
                response = self.response_calculator.calculate_response(
                    spend=optimal_spend[i],
                    coef=self.media_params.coefficients[channel],
                    alpha=self.media_params.alphas[channel],
                    inflexion=self.media_params.inflexions[channel],
                )
                optimal_responses[channel] = response

            # Prepare result
            return AllocationResult(
                optimal_allocations=pd.DataFrame(
                    {
                        "channel": self.mmm_data.mmmdata_spec.paid_media_spends,
                        "current_spend": initial_metrics["hist_spend_mean"],
                        "optimal_spend": optimal_spend,
                        "current_response": [
                            initial_metrics["init_responses"][ch]
                            for ch in self.mmm_data.mmmdata_spec.paid_media_spends
                        ],
                        "optimal_response": [
                            optimal_responses[ch] for ch in self.mmm_data.mmmdata_spec.paid_media_spends
                        ],
                    }
                ),
                predicted_responses=pd.DataFrame(
                    {
                        "channel": self.mmm_data.mmmdata_spec.paid_media_spends,
                        "response": list(optimal_responses.values()),
                    }
                ),
                response_curves=self._generate_response_curves(
                    optimal_spend=optimal_spend, current_spend=initial_metrics["hist_spend_mean"]
                ),
                metrics={
                    "total_budget": initial_metrics["budget_unit"] * initial_metrics["date_range"].n_periods,
                    "response_lift": (sum(optimal_responses.values()) / initial_metrics["init_response_total"]) - 1,
                    "optimization_iterations": result["nit"],
                    "optimization_status": result["success"],
                },
            )

        except Exception as e:
            raise ValueError(f"Max response optimization failed: {str(e)}")

    def _optimize_target_efficiency(
        self, initial_metrics: Dict[str, Any], config: AllocationConfig
    ) -> AllocationResult:
        """Optimize for target efficiency (ROAS/CPA).

        Args:
            initial_metrics: Dictionary containing initial metrics including:
                - hist_spend_mean: Current spend by channel
                - init_responses: Initial response by channel
                - init_response_total: Total initial response
                - init_spend_total: Total initial spend
                - budget_unit: Budget per period
                - date_range: DateRange object
            config: AllocationConfig object containing:
                - target_value: Target ROAS/CPA value
                - constraints: Spend constraints
                - optim_algo: Optimization algorithm
                - maxeval: Maximum evaluations
                - constr_mode: Constraint mode

        Returns:
            AllocationResult containing optimization results
        """
        try:
            # Set default target value if not provided
            if config.target_value is None:
                if self.mmm_data.mmmdata_spec.dep_var_type == "revenue":
                    # For revenue, target is 80% of initial ROAS
                    config.target_value = (
                        initial_metrics["init_response_total"] / initial_metrics["init_spend_total"]
                    ) * 0.8
                else:
                    # For conversion, target is 120% of initial CPA
                    config.target_value = (
                        initial_metrics["init_spend_total"] / initial_metrics["init_response_total"]
                    ) * 1.2

            # Setup optimization
            x0 = initial_metrics["hist_spend_mean"].values
            bounds = config.constraints.get_bounds(initial_metrics["hist_spend_mean"])

            def objective(x):
                """Objective function to maximize total response."""
                total_response = 0
                for i, channel in enumerate(self.mmm_data.mmmdata_spec.paid_media_spends):
                    response = self.response_calculator.calculate_response(
                        spend=x[i],
                        coef=self.media_params.coefficients[channel],
                        alpha=self.media_params.alphas[channel],
                        inflexion=self.media_params.inflexions[channel],
                    )
                    total_response += response
                return -total_response  # Negative because we're minimizing

            def efficiency_constraint(x):
                """Constraint function to maintain target efficiency."""
                total_response = -objective(x)  # Negative because objective returns negative
                total_spend = np.sum(x)

                if self.mmm_data.mmmdata_spec.dep_var_type == "revenue":
                    # For revenue, maintain ROAS >= target
                    return total_response / total_spend - config.target_value
                else:
                    # For conversion, maintain CPA <= target
                    return total_spend / total_response - config.target_value

            constraints = [
                {"type": "eq" if config.constr_mode == ConstrMode.EQUALITY else "ineq", "fun": efficiency_constraint}
            ]

            # Run optimization
            result = self.optimizer.optimize(
                objective_func=objective,
                bounds=bounds,
                constraints=constraints,
                initial_guess=x0,
                method=config.optim_algo,
                maxeval=config.maxeval,
            )

            if not result["success"]:
                print(f"Warning: Optimization may not have converged. Message: {result['message']}")

            # Get optimal allocations
            optimal_spend = result["x"]
            optimal_responses = {}

            # Calculate responses for optimal spend
            for i, channel in enumerate(self.mmm_data.mmmdata_spec.paid_media_spends):
                response = self.response_calculator.calculate_response(
                    spend=optimal_spend[i],
                    coef=self.media_params.coefficients[channel],
                    alpha=self.media_params.alphas[channel],
                    inflexion=self.media_params.inflexions[channel],
                )
                optimal_responses[channel] = response

            # Calculate total metrics
            total_spend = sum(optimal_spend)
            total_response = sum(optimal_responses.values())

            # Calculate efficiency metrics
            achieved_efficiency = (
                total_response / total_spend
                if self.mmm_data.mmmdata_spec.dep_var_type == "revenue"
                else total_spend / total_response
            )

            # Create result
            return AllocationResult(
                optimal_allocations=pd.DataFrame(
                    {
                        "channel": self.mmm_data.mmmdata_spec.paid_media_spends,
                        "current_spend": initial_metrics["hist_spend_mean"],
                        "optimal_spend": optimal_spend,
                        "current_response": [
                            initial_metrics["init_responses"][ch]
                            for ch in self.mmm_data.mmmdata_spec.paid_media_spends
                        ],
                        "optimal_response": [
                            optimal_responses[ch] for ch in self.mmm_data.mmmdata_spec.paid_media_spends
                        ],
                    }
                ),
                predicted_responses=pd.DataFrame(
                    {
                        "channel": self.mmm_data.mmmdata_spec.paid_media_spends,
                        "response": list(optimal_responses.values()),
                    }
                ),
                response_curves=self._generate_response_curves(
                    optimal_spend=optimal_spend, current_spend=initial_metrics["hist_spend_mean"]
                ),
                metrics={
                    "total_budget": total_spend * initial_metrics["date_range"].n_periods,
                    "response_lift": (total_response / initial_metrics["init_response_total"]) - 1,
                    "achieved_efficiency": achieved_efficiency,
                    "target_efficiency": config.target_value,
                    "optimization_iterations": result["nit"],
                    "optimization_status": result["success"],
                    "total_response": total_response,
                    "total_spend": total_spend,
                },
            )

        except Exception as e:
            raise ValueError(f"Target efficiency optimization failed: {str(e)}")

    def _generate_response_curves(
        self, optimal_spend: np.ndarray, current_spend: np.ndarray, n_points: int = 100
    ) -> pd.DataFrame:
        """Generate response curves for visualization.

        Args:
            optimal_spend: Array of optimal spend values
            current_spend: Array of current spend values
            n_points: Number of points to generate for each curve

        Returns:
            DataFrame containing response curves for each channel
        """
        curves_data = []

        for i, channel in enumerate(self.mmm_data.mmmdata_spec.paid_media_spends):
            # Generate spend range
            max_spend = max(optimal_spend[i], current_spend[i]) * 1.5
            spend_range = np.linspace(0, max_spend, n_points)

            # Calculate response values
            response_values = np.array(
                [
                    self.response_calculator.calculate_response(
                        spend=spend,
                        coef=self.media_params.coefficients[channel],
                        alpha=self.media_params.alphas[channel],
                        inflexion=self.media_params.inflexions[channel],
                    )
                    for spend in spend_range
                ]
            )

            # Calculate marginal response (response per unit spend)
            marginal_response = np.gradient(response_values, spend_range)

            # Calculate ROI
            roi = np.where(spend_range > 0, response_values / spend_range, 0)

            # Create curve data points
            for j in range(n_points):
                curves_data.append(
                    {
                        "channel": channel,
                        "spend": spend_range[j],
                        "response": response_values[j],
                        "marginal_response": marginal_response[j],
                        "roi": roi[j],
                        "is_current": np.isclose(spend_range[j], current_spend[i], rtol=1e-3),
                        "is_optimal": np.isclose(spend_range[j], optimal_spend[i], rtol=1e-3),
                    }
                )

        # Convert to DataFrame
        curve_df = pd.DataFrame(curves_data)

        # Add metadata for visualization
        metadata = {
            "channel": list(self.mmm_data.mmmdata_spec.paid_media_spends),
            "current_spend": current_spend,
            "optimal_spend": optimal_spend,
            "current_response": [
                self.response_calculator.calculate_response(
                    spend=spend,
                    coef=self.media_params.coefficients[channel],
                    alpha=self.media_params.alphas[channel],
                    inflexion=self.media_params.inflexions[channel],
                )
                for spend, channel in zip(current_spend, self.mmm_data.mmmdata_spec.paid_media_spends)
            ],
            "optimal_response": [
                self.response_calculator.calculate_response(
                    spend=spend,
                    coef=self.media_params.coefficients[channel],
                    alpha=self.media_params.alphas[channel],
                    inflexion=self.media_params.inflexions[channel],
                )
                for spend, channel in zip(optimal_spend, self.mmm_data.mmmdata_spec.paid_media_spends)
            ],
        }

        # Add summary statistics
        summary_stats = {
            "total_current_spend": current_spend.sum(),
            "total_optimal_spend": optimal_spend.sum(),
            "total_current_response": sum(metadata["current_response"]),
            "total_optimal_response": sum(metadata["optimal_response"]),
            "response_lift_pct": (sum(metadata["optimal_response"]) / sum(metadata["current_response"]) - 1) * 100,
        }

        # Add to curve DataFrame as attributes
        curve_df.attrs["metadata"] = metadata
        curve_df.attrs["summary_stats"] = summary_stats

        return curve_df

    def allocate(self, config: AllocationConfig) -> AllocationResult:
        """Run budget allocation optimization.

        Args:
            config: Allocation configuration

        Returns:
            AllocationResult containing optimization results
        """
        try:
            # Get date range
            date_range = self._process_date_range(config.date_range)

            # Get sorted media spends
            media_spend_sorted = np.array(self.mmm_data.mmmdata_spec.paid_media_spends)

            # Calculate initial metrics
            initial_metrics = self._calculate_initial_metrics(
                date_range=date_range, media_spend_sorted=media_spend_sorted, total_budget=config.total_budget
            )

            # Run optimization based on scenario
            if config.scenario == OptimizationScenario.MAX_RESPONSE:
                result = self._optimize_max_response(initial_metrics=initial_metrics, config=config)
            else:
                result = self._optimize_target_efficiency(initial_metrics=initial_metrics, config=config)

            # Generate response curves if plots requested
            if config.plots:
                result.response_curves = self._generate_response_curves(
                    optimal_spend=result.optimal_allocations["optimal_spend"].values,
                    current_spend=result.optimal_allocations["current_spend"].values,
                )

            return result

        except Exception as e:
            print(f"Error during allocation: {str(e)}")
            raise

    def _validate_date_data(self) -> None:
        """Validate date data during initialization."""
        try:
            date_col = self._get_date_column_name()
            if date_col not in self.mmm_data.data.columns:
                raise ValueError(f"Date column '{date_col}' not found in data")

            # Try converting to datetime
            dates = pd.to_datetime(self.mmm_data.data[date_col], format=None)

            # Ensure dates are sorted
            if not dates.is_monotonic_increasing:
                raise ValueError("Dates must be in ascending order")

            # Check for missing dates
            if dates.isna().any():
                raise ValueError("Date column contains missing values")

        except Exception as e:
            raise ValueError(f"Invalid date data: {str(e)}")

    def _get_date_column_name(self) -> str:
        """Get the date column name, handling cases where it might be a list."""
        date_var = self.mmm_data.mmmdata_spec.date_var
        if isinstance(date_var, list):
            return date_var[0]
        return date_var

================
File: media_response.py
================
"""
media_response_parameters.py - Calculates parameters for media response curves

This module implements the parameter calculation logic from allocator.R's get_hill_params(),
using the ParetoResult data structure from data_mapper.py.
"""

from dataclasses import dataclass
from typing import Dict, Optional
import pandas as pd
import numpy as np

from robyn.data.entities.mmmdata import MMMData
from robyn.modeling.pareto.pareto_optimizer import ParetoResult


@dataclass
class MediaResponseParameters:
    """Container for media response parameters calculated for each channel."""

    alphas: Dict[str, float]
    inflexions: Dict[str, float]
    coefficients: Dict[str, float]


class MediaResponseParamsCalculator:
    """Calculates response curve parameters for media channels."""

    def __init__(
        self,
        mmm_data: MMMData,
        pareto_result: ParetoResult,
        select_model: str,
    ):
        """Initialize calculator with model data and parameters.

        Args:
            mmm_data: Marketing mix modeling data
            pareto_result: Pareto optimization results containing model data
            select_model: Selected model identifier
        """
        self.mmm_data = mmm_data
        self.pareto_result = pareto_result
        self.select_model = select_model

        # Get media channels in sorted order
        self.media_channels = np.array(self.mmm_data.mmmdata_spec.paid_media_spends)
        self.media_order = np.argsort(self.media_channels)
        self.sorted_channels = self.media_channels[self.media_order]

    def calculate_parameters(self) -> MediaResponseParameters:
        """Calculate response parameters for all media channels."""
        # Get hyperparameters for selected model
        dt_hyppar = self.pareto_result.result_hyp_param[
            self.pareto_result.result_hyp_param["solID"] == self.select_model
        ]

        # Get adstocked media data
        adstocked_data = self._get_adstocked_media_data()

        # Calculate parameters for each channel
        alphas = {}
        inflexions = {}
        coefficients = {}

        for channel in self.sorted_channels:
            # Get alpha parameter
            alpha_key = f"{channel}_alphas"
            alphas[channel] = dt_hyppar[alpha_key].iloc[0]

            # Get gamma and calculate inflexion point
            gamma_key = f"{channel}_gammas"
            gamma = dt_hyppar[gamma_key].iloc[0]

            channel_data = adstocked_data[channel]
            value_range = np.array([channel_data.min(), channel_data.max()])
            inflexions[channel] = np.dot(value_range, [1 - gamma, gamma])

            # Get coefficient
            coef_data = self.pareto_result.x_decomp_agg[
                (self.pareto_result.x_decomp_agg["solID"] == self.select_model)
                & (self.pareto_result.x_decomp_agg["rn"] == channel)
            ]
            coefficients[channel] = coef_data["coef"].iloc[0]

        return MediaResponseParameters(alphas=alphas, inflexions=inflexions, coefficients=coefficients)

    def _get_adstocked_media_data(self) -> pd.DataFrame:
        """Get adstocked media data for the selected model within the specified window."""
        # Filter for adstocked media data
        adstocked_data = self.pareto_result.media_vec_collect[
            (self.pareto_result.media_vec_collect["type"] == "adstockedMedia")
            & (self.pareto_result.media_vec_collect["solID"] == self.select_model)
        ][self.sorted_channels]

        # Get window indices
        start_idx = self.mmm_data.mmmdata_spec.rolling_window_start_which
        end_idx = self.mmm_data.mmmdata_spec.rolling_window_end_which

        # Return windowed data
        return adstocked_data.iloc[start_idx : end_idx + 1]

    def get_parameter_summary(self) -> pd.DataFrame:
        """Generate a summary DataFrame of all parameters."""
        params = self.calculate_parameters()

        return pd.DataFrame(
            {
                "channel": list(self.sorted_channels),
                "alpha": [params.alphas[ch] for ch in self.sorted_channels],
                "inflexion": [params.inflexions[ch] for ch in self.sorted_channels],
                "coefficient": [params.coefficients[ch] for ch in self.sorted_channels],
            }
        )

================
File: response_calculator.py
================
from typing import Dict, List, Tuple
import numpy as np
import pandas as pd


class ResponseCurveCalculator:
    """Calculates response curves and related metrics."""

    def calculate_response(
        self,
        spend: float,
        coef: float,
        alpha: float,
        inflexion: float,
        x_hist_carryover: float = 0,
        get_sum: bool = True,
    ) -> float:
        """
        Calculate response for given spend level and parameters.

        Implementation follows fx_objective from allocator.R
        """
        # Adstock scales
        x_adstocked = spend + np.mean(x_hist_carryover)

        # Hill transformation
        if get_sum:
            x_out = coef * np.sum((1 + inflexion**alpha / x_adstocked**alpha) ** -1)
        else:
            x_out = coef * ((1 + inflexion**alpha / x_adstocked**alpha) ** -1)

        return x_out

    def calculate_gradient(
        self, spend: float, coef: float, alpha: float, inflexion: float, x_hist_carryover: float = 0
    ) -> float:
        """
        Calculate gradient for optimization.

        Implementation follows fx_gradient from allocator.R
        """
        x_adstocked = spend + np.mean(x_hist_carryover)
        x_out = -coef * np.sum(
            (alpha * (inflexion**alpha) * (x_adstocked ** (alpha - 1))) / (x_adstocked**alpha + inflexion**alpha) ** 2
        )
        return x_out

    def get_response_curve(
        self, spend_range: np.ndarray, coef: float, alpha: float, inflexion: float, x_hist_carryover: float = 0
    ) -> Tuple[np.ndarray, np.ndarray]:
        """Generate response curve over a range of spend values."""
        responses = np.array(
            [
                self.calculate_response(spend, coef, alpha, inflexion, x_hist_carryover, get_sum=False)
                for spend in spend_range
            ]
        )

        return spend_range, responses
